{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Smartspace Workflow Documentation","text":"<p>The Smartspace Workflow SDK is a powerful framework used in conjunction with the Smartspace platform smartspace.ai to enable Generative AI solutions built for enterprise use cases.</p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Block Reference</li> <li>Concepts<ul> <li>Blocks</li> <li>Channels</li> </ul> </li> </ul>"},{"location":"cli/","title":"CLI","text":"<p>This documentation will help users understand how to use the SmartSpace CLI tool, designed to deploy and debug 'blocks' within a workflow.</p>"},{"location":"cli/#1-installation","title":"1. Installation","text":"<p>pip <pre><code>pip install smartspace-ai\n</code></pre></p> <p>poetry <pre><code>poetry add smartspace-ai\n</code></pre></p> <p>Once installed, you can use the <code>smartspace</code> command in your terminal to interact with the SmartSpace API.</p>"},{"location":"cli/#2-configuration","title":"2. Configuration","text":"<p>The CLI tool requires configuration settings for interacting with the SmartSpace API. You can configure the tool using the <code>config</code> command.</p> Configuration Details <p>You can find the configuration ids in the SmartSpace Admin portal in the \"Config API\" section.</p>"},{"location":"cli/#command","title":"Command:","text":"<pre><code>smartspace config [OPTIONS]\n</code></pre>"},{"location":"cli/#options","title":"Options:","text":"<ul> <li><code>--api-url</code>: The base URL for the SmartSpace API.</li> <li><code>--tenant-id</code>: Your Microsoft Tenant ID.</li> <li><code>--client-id</code>: Your SmartSpace Client ID.</li> </ul> <p>Example: <pre><code>smartspace config --api-url https://api.smartspace.com --tenant-id your-tenant-id --client-id your-client-id\n</code></pre></p> <p>This command updates the configuration file located at <code>~/.smartspace/config.json</code>.</p>"},{"location":"cli/#3-login","title":"3. Login","text":"<p>To authenticate with SmartSpace, use the <code>login</code> command. There are two options for login: 1. Device Code Authentication (recommended for headless environments). 2. Interactive Authentication.</p>"},{"location":"cli/#command_1","title":"Command:","text":"<pre><code>smartspace login [OPTIONS]\n</code></pre>"},{"location":"cli/#options_1","title":"Options:","text":"<ul> <li><code>--device-code</code>: If specified, login using a device code flow, prompting the user to authorize the app on another device.</li> </ul> <p>Example: <pre><code>smartspace login --device-code\n</code></pre></p> <p>If successful, the login command will save the token cache for future interactions.</p>"},{"location":"cli/#4-blocks-management","title":"4. Blocks Management","text":"<p>The CLI provides tools to publish and debug blocks in your workflow.</p>"},{"location":"cli/#41-publishing-blocks","title":"4.1. Publishing Blocks","text":"<p>To publish a block, use the <code>publish</code> command. This command compresses your blocks into a <code>.zip</code> file and uploads them to the SmartSpace API.</p>"},{"location":"cli/#command_2","title":"Command:","text":"<pre><code>smartspace blocks publish [OPTIONS]\n</code></pre>"},{"location":"cli/#arguments","title":"Arguments:","text":"<ul> <li><code>name</code>: The name of the block set.</li> <li><code>path</code>: The path to the directory containing your blocks (default is the current directory).</li> </ul> <p>Example: <pre><code>smartspace blocks publish my_block_set /path/to/blocks\n</code></pre></p> <p>This will output the names of the blocks being published and send the ZIP file to the configured API.</p>"},{"location":"cli/#42-debugging-blocks","title":"4.2. Debugging Blocks","text":"<p>To start debugging a block, use the <code>debug</code> command. This monitors file changes and synchronizes block registration with the server.</p>"},{"location":"cli/#command_3","title":"Command:","text":"<pre><code>smartspace blocks debug [OPTIONS]\n</code></pre>"},{"location":"cli/#options_2","title":"Options:","text":"<ul> <li><code>path</code>: The path to the block directory to debug (default is the current working directory).</li> <li><code>--poll</code>: Use a polling observer for file system events (useful for network filesystems).</li> </ul> <p>Example: <pre><code>smartspace blocks debug /path/to/blocks\n</code></pre></p> <p>This command connects to the SmartSpace server, registers your blocks, and waits for file changes to trigger updates.</p>"},{"location":"cli/#5-utilities","title":"5. Utilities","text":""},{"location":"cli/#51-configuration-management","title":"5.1. Configuration Management","text":"<p>The configuration is stored locally in a JSON file. Use the <code>config</code> command to set or update your configuration details, such as API URLs, client IDs, and tenant IDs. The configuration file is located at:</p> <pre><code>~/.smartspace/config.json\n</code></pre> <p>Use the <code>config</code> command (as described in Section 2) to manage these settings.</p>"},{"location":"cli/#6-example-workflow","title":"6. Example Workflow","text":"<ol> <li> <p>Configure the CLI with the API URL, tenant ID, and client ID:    <pre><code>smartspace config --api-url https://api.smartspace.com --tenant-id your-tenant-id --client-id your-client-id\n</code></pre></p> </li> <li> <p>Login to the CLI:    <pre><code>smartspace login --device-code\n</code></pre></p> </li> <li> <p>Publish your blocks:    <pre><code>smartspace blocks publish my_block_set /path/to/blocks\n</code></pre></p> </li> <li> <p>Debug your blocks during development:    <pre><code>smartspace blocks debug /path/to/blocks\n</code></pre></p> </li> </ol>"},{"location":"cli/#7-error-handling","title":"7. Error Handling","text":"<ul> <li>If you encounter missing configuration errors while trying to publish or debug, ensure that the API URL, client ID, and tenant ID are correctly set using the <code>config</code> command.</li> <li>If authentication fails, retry the login command or verify the client ID and tenant ID in the configuration.</li> </ul>"},{"location":"block-reference/","title":"Overview","text":"<p>Welcome to the Blocks Reference Documentation. This section provides detailed information about each block available within your system, explaining their functionality, configurations, inputs, and outputs. Each block serves a specific purpose, helping you to build workflows and automate tasks with precision. The documentation is structured to offer a comprehensive understanding of how to use these blocks effectively.</p>"},{"location":"block-reference/#what-is-a-block","title":"What is a Block?","text":"<p>A block is a modular unit that performs a specific function. Each block takes one or more inputs, processes them according to its defined logic, and produces an output. Blocks can be combined in various workflows to accomplish complex tasks, allowing for highly customizable operations.</p>"},{"location":"block-reference/#types-of-blocks","title":"Types of Blocks","text":"<p>Blocks can serve different purposes based on their category. Some common types include:</p> <ul> <li> <p>Function Blocks: These blocks perform specific actions such as data processing, manipulation, or API requests. Examples include parsing JSON, handling strings, and merging lists.</p> </li> <li> <p>Utility Blocks: These blocks handle auxiliary operations like logging, error handling, or providing utility functions that can be reused across different workflows.</p> </li> <li> <p>Control Blocks: These blocks manage the flow of execution, such as conditional branching, looping, or handling asynchronous tasks.</p> </li> </ul>"},{"location":"block-reference/#how-to-use-the-documentation","title":"How to Use the Documentation","text":"<p>Each block has its own dedicated page with the following structure to help you understand how it works:</p> <ol> <li>Overview: A brief explanation of the block's purpose and functionality.</li> <li>Examples: Practical usage examples to demonstrate how the block can be applied in different scenarios.</li> <li>Error Handling: Information about potential errors that can occur during execution and how the block handles them.</li> <li>FAQ: Frequently Asked Questions that address common concerns or advanced usage tips for the block.</li> </ol>"},{"location":"block-reference/#configuration-and-customization","title":"Configuration and Customization","text":"<p>Many blocks come with configurable parameters. These parameters allow you to fine-tune how a block operates. For example, you might configure a token limit for a string truncation block or set the method (GET, POST) for an HTTP request block. The configuration details are explained in each block\u2019s documentation.</p>"},{"location":"block-reference/#inputs-and-outputs","title":"Inputs and Outputs","text":"<p>Blocks accept inputs, which they process to produce outputs. The expected format of the inputs and the structure of the outputs are clearly defined in each block\u2019s page. This information is crucial to ensure that blocks are used correctly within workflows.</p>"},{"location":"block-reference/#best-practices","title":"Best Practices","text":"<ul> <li> <p>Understand the Input/Output Requirements: Before using a block, make sure you understand the type of input it requires and the output it produces. Mismatched types or missing inputs can cause errors.</p> </li> <li> <p>Modularize Your Workflows: Blocks can be combined in sequences to perform complex tasks. Make use of the modularity by splitting large workflows into smaller, more manageable blocks.</p> </li> <li> <p>Handle Errors Gracefully: Many blocks include built-in error handling. Understanding how each block handles errors will help you build more robust workflows.</p> </li> </ul>"},{"location":"block-reference/#conclusion","title":"Conclusion","text":"<p>This documentation serves as a comprehensive guide to understanding and utilizing the various blocks available. By leveraging these blocks, you can create powerful, dynamic workflows that suit your specific needs. For detailed information on each block, click through to its dedicated page.</p> <p>If you\u2019re new to this system, we recommend starting with basic blocks to understand their structure and then gradually moving to more advanced blocks.</p> <p>Happy building!</p>"},{"location":"block-reference/Analyzer/","title":"Analyzer","text":""},{"location":"block-reference/Analyzer/#overview","title":"Overview","text":"<p>The <code>Analyzer</code> Block is designed to process a collection of documents, interact with an LLM (Language Learning Model), and generate a response. It provides tools for summarizing and generating content based on sources and citations from the knowledge base. It ensures that sources used in the response are properly cited.</p> <p>This block allows customization of the response schema, enabling flexibility in the format of the output (string or structured data).</p>"},{"location":"block-reference/Analyzer/#description","title":"Description","text":""},{"location":"block-reference/Analyzer/#metadata","title":"Metadata","text":"<ul> <li>Category: Agent</li> </ul>"},{"location":"block-reference/Analyzer/#configuration-options","title":"Configuration Options","text":"<p>No configuration options available.</p>"},{"location":"block-reference/Analyzer/#inputs","title":"Inputs","text":"Name Data Type Description documents <code>list[SearchResult]</code> message <code>list[ContentItem] or str</code>"},{"location":"block-reference/Analyzer/#outputs","title":"Outputs","text":"Name Data Type Description sources <code>list[Source]</code> content <code>ResponseSchemaT</code>"},{"location":"block-reference/Analyzer/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/Analyzer/#examples","title":"Example(s)","text":""},{"location":"block-reference/Analyzer/#example-1-analyze-documents-and-generate-a-response","title":"Example 1: Analyze documents and generate a response","text":"<ul> <li>Create an <code>Analyzer</code> Block.</li> <li>Set the <code>response_schema</code> to <code>\"string\"</code> and configure the <code>llm_config</code> for your LLM model.</li> <li>Provide a list of documents and a message, such as <code>\"Generate a summary of these documents.\"</code></li> <li>The Block will output a response from the LLM, ensuring that sources are cited appropriately.</li> </ul>"},{"location":"block-reference/Analyzer/#error-handling","title":"Error Handling","text":"<ul> <li>If the LLM response is null, an <code>LLMError</code> will be raised.</li> <li>If the response type is unexpected, an exception will be raised.</li> <li>If there is an issue with JSON content formatting, the Block will attempt to fix the escaping, but will raise a runtime error if unable to process it.</li> </ul>"},{"location":"block-reference/Analyzer/#faq","title":"FAQ","text":"What happens if the response schema is not a string? <p>If the response schema is not a string, the block will expect the content to be returned in JSON format, with citations appropriately placed using a different format from string-based responses.</p> How does the block ensure sources are properly cited? <p>The block automatically replaces placeholders like <code>(source_1)</code> with citations in the output content, ensuring all cited sources are included in the final response.</p> Can I use custom LLM configurations? <p>Yes, you can configure the <code>llm_config</code> to match your desired LLM model. The Block supports custom pre-prompts and other LLM configurations.</p>"},{"location":"block-reference/Buffer/","title":"Buffer","text":""},{"location":"block-reference/Buffer/#overview","title":"Overview","text":"<p>The <code>Buffer</code> Block temporarily stores values in a list and releases them one by one when the block is ready. This allows for buffering of data to control the flow of values in a sequence. The block holds incoming values until a signal is received to process the next one. It ensures that only one value is processed at a time, allowing better control over sequential workflows.</p>"},{"location":"block-reference/Buffer/#description","title":"Description","text":""},{"location":"block-reference/Buffer/#configuration-options","title":"Configuration Options","text":"<p>No configuration options available.</p>"},{"location":"block-reference/Buffer/#inputs","title":"Inputs","text":"Name Data Type Description value <code>ValueT</code> next <code>Any</code>"},{"location":"block-reference/Buffer/#outputs","title":"Outputs","text":"Name Data Type Description output <code>ValueT</code>"},{"location":"block-reference/Buffer/#state-variables","title":"State Variables","text":"Name Data Type Description values <code>list[ValueT]</code> ready <code>bool</code>"},{"location":"block-reference/Buffer/#examples","title":"Example(s)","text":""},{"location":"block-reference/Buffer/#example-1-buffering-values-and-processing-them-one-by-one","title":"Example 1: Buffering values and processing them one by one","text":"<ul> <li>Create a <code>Buffer</code> Block.</li> <li>Send values sequentially using the <code>value()</code> step, such as <code>buffer.value(10)</code> and <code>buffer.value(20)</code>.</li> <li>Use the <code>next()</code> step to signal that the buffer is ready to process the next value.</li> <li>The Block will output each value in sequence, processing one at a time.</li> </ul>"},{"location":"block-reference/Buffer/#example-2-processing-multiple-values-in-a-controlled-manner","title":"Example 2: Processing multiple values in a controlled manner","text":"<ul> <li>Set up a <code>Buffer</code> Block to collect multiple incoming values.</li> <li>Use the <code>value()</code> step to send values into the buffer: <code>buffer.value(\"A\")</code>, <code>buffer.value(\"B\")</code>.</li> <li>Use <code>next()</code> to release values sequentially, ensuring that each value is handled one by one before the next is processed.</li> </ul>"},{"location":"block-reference/Buffer/#error-handling","title":"Error Handling","text":"<ul> <li>If the buffer is not ready, the <code>next()</code> step will not process any values until the Block signals readiness.</li> <li>If the buffer is empty, no value will be sent when <code>next()</code> is called.</li> </ul>"},{"location":"block-reference/Buffer/#faq","title":"FAQ","text":"What happens if I call <code>next()</code> when the buffer is empty? <p>If there are no values in the buffer, calling <code>next()</code> will not send any output, and the Block will simply remain ready to process new values.</p> Can I add multiple values to the buffer? <p>Yes, you can append multiple values to the buffer by calling the <code>value()</code> step repeatedly. The buffer will store all the values and release them one by one as <code>next()</code> is called.</p> How does the block handle readiness? <p>The Block uses a <code>ready</code> flag to control when it is ready to release the next value from the buffer. It becomes ready once the previous value has been processed and <code>next()</code> has been called.</p>"},{"location":"block-reference/Cast/","title":"Cast","text":""},{"location":"block-reference/Cast/#overview","title":"Overview","text":"<p>The <code>Cast</code> Block converts an input into the specified type based on a provided schema. This is useful for ensuring that inputs conform to a specific structure or type.</p>"},{"location":"block-reference/Cast/#description","title":"Description","text":"<p>Takes in an any input and will atempt to convert the input to the specified schema</p>"},{"location":"block-reference/Cast/#metadata","title":"Metadata","text":"<ul> <li>Category: Misc</li> </ul>"},{"location":"block-reference/Cast/#configuration-options","title":"Configuration Options","text":"<p>No configuration options available.</p>"},{"location":"block-reference/Cast/#inputs","title":"Inputs","text":"Name Data Type Description item <code>Any</code>"},{"location":"block-reference/Cast/#outputs","title":"Outputs","text":"Name Data Type Description result <code>ItemT</code>"},{"location":"block-reference/Cast/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/Cast/#examples","title":"Example(s)","text":""},{"location":"block-reference/Cast/#example-1-cast-a-string-to-a-number","title":"Example 1: Cast a string to a number","text":"<ul> <li>Create a <code>Cast</code> Block.</li> <li>Set the schema to <code>{\"type\": \"number\"}</code>.</li> <li>Provide the input: <code>\"123\"</code>.</li> <li>The Block will output: <code>123</code>.</li> </ul>"},{"location":"block-reference/Cast/#example-2-cast-a-json-string-to-an-object","title":"Example 2: Cast a JSON string to an object","text":"<ul> <li>Set up a <code>Cast</code> Block.</li> <li>Set the schema to <code>{\"type\": \"object\"}</code>.</li> <li>Provide the input: <code>'{\"name\": \"John\"}'</code>.</li> <li>The Block will output: <code>{\"name\": \"John\"}</code>.</li> </ul>"},{"location":"block-reference/Cast/#error-handling","title":"Error Handling","text":"<ul> <li>If the input cannot be cast to the specified type, the Block will raise a <code>ValueError</code>.</li> </ul>"},{"location":"block-reference/Cast/#faq","title":"FAQ","text":"What happens if the input doesn't match the schema? <p>The Block will raise an error or attempt to convert the input according to the schema.</p>"},{"location":"block-reference/Collect/","title":"Collect","text":""},{"location":"block-reference/Collect/#overview","title":"Overview","text":"<p>The <code>Collect</code> Block is used to gather data from a channel and store it in a list. Once the channel closes, the Block outputs the collected items as a list.</p> <p>The <code>Collect</code> Block listens for events from an <code>InputChannel</code> and appends the incoming data to an internal list (<code>items_state</code>). When the channel sends a close event, the collected data is sent out via the <code>items</code> output.</p>"},{"location":"block-reference/Collect/#description","title":"Description","text":"<p>Collects data from a channel and outputs them as a list once the channel closes</p>"},{"location":"block-reference/Collect/#metadata","title":"Metadata","text":"<ul> <li>Category: Function</li> </ul>"},{"location":"block-reference/Collect/#configuration-options","title":"Configuration Options","text":"<p>No configuration options available.</p>"},{"location":"block-reference/Collect/#inputs","title":"Inputs","text":"Name Data Type Description item <code>InputChannel[ItemT]</code>"},{"location":"block-reference/Collect/#outputs","title":"Outputs","text":"Name Data Type Description items <code>list[ItemT]</code>"},{"location":"block-reference/Collect/#state-variables","title":"State Variables","text":"Name Data Type Description items_state <code>list[ItemT]</code>"},{"location":"block-reference/Collect/#examples","title":"Example(s)","text":""},{"location":"block-reference/Collect/#example-1-collect-data-from-an-input-channel","title":"Example 1: Collect data from an input channel","text":"<ul> <li>Create a <code>Collect</code> Block.</li> <li>Provide an <code>InputChannel</code> that sends individual pieces of data.</li> <li>As the <code>InputChannel</code> sends data, the Block will collect each item.</li> <li>When the channel closes, the Block will output the collected list.</li> </ul>"},{"location":"block-reference/Collect/#example-2-gather-event-based-data","title":"Example 2: Gather event-based data","text":"<ul> <li>Use the <code>Collect</code> Block to accumulate data from an event stream.</li> <li>For example, during a long-running process, events can be sent via an <code>InputChannel</code>.</li> <li>Once the process completes and the channel closes, the Block will output the accumulated data as a list of events.</li> </ul>"},{"location":"block-reference/Collect/#error-handling","title":"Error Handling","text":"<ul> <li>The <code>Collect</code> Block assumes that data will be available on the channel. If no data is received, the output list will be empty.</li> <li>Make sure the channel is properly closed; otherwise, the Block will not output the collected data.</li> </ul>"},{"location":"block-reference/Collect/#faq","title":"FAQ","text":"What happens if no data is sent before the channel closes? <p>If no data is received from the channel before it closes, the <code>Collect</code> Block will output an empty list.</p> Can I use this block to collect data from multiple channels? <p>The current design of the <code>Collect</code> Block focuses on a single channel. To collect data from multiple channels, you'll need to implement additional logic to manage multiple channels.</p> What happens if the channel does not send a close event? <p>The <code>Collect</code> Block only sends the collected data when it detects a close event. If the channel remains open indefinitely, the collected data will not be outputted.</p>"},{"location":"block-reference/Concat/","title":"Concat","text":""},{"location":"block-reference/Concat/#overview","title":"Overview","text":"<p>The <code>Concat</code> Block concatenates two sequences, which can either be lists or strings. This Block takes two input sequences and returns the result of appending the second sequence to the first. It supports both string and list types, making it useful for combining different kinds of data.</p>"},{"location":"block-reference/Concat/#description","title":"Description","text":"<p>Concatenates 2 lists or strings</p>"},{"location":"block-reference/Concat/#metadata","title":"Metadata","text":"<ul> <li>Category: Function</li> </ul>"},{"location":"block-reference/Concat/#configuration-options","title":"Configuration Options","text":"<p>No configuration options available.</p>"},{"location":"block-reference/Concat/#inputs","title":"Inputs","text":"Name Data Type Description a <code>SequenceT</code> b <code>SequenceT</code>"},{"location":"block-reference/Concat/#outputs","title":"Outputs","text":"Name Data Type Description result <code>SequenceT</code>"},{"location":"block-reference/Concat/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/Concat/#examples","title":"Example(s)","text":""},{"location":"block-reference/Concat/#example-1-concatenate-two-strings","title":"Example 1: Concatenate two strings","text":"<ul> <li>Create a <code>Concat</code> Block.</li> <li>Provide the input strings: <code>\"Hello, \"</code> and <code>\"World!\"</code>.</li> <li>The Block will output: <code>\"Hello, World!\"</code>, concatenating the two strings.</li> </ul>"},{"location":"block-reference/Concat/#example-2-concatenate-two-lists","title":"Example 2: Concatenate two lists","text":"<ul> <li>Set up a <code>Concat</code> Block.</li> <li>Provide the input lists: <code>[1, 2, 3]</code> and <code>[4, 5, 6]</code>.</li> <li>The Block will output: <code>[1, 2, 3, 4, 5, 6]</code>, merging the two lists into one.</li> </ul>"},{"location":"block-reference/Concat/#example-3-handle-empty-inputs","title":"Example 3: Handle empty inputs","text":"<ul> <li>Create a <code>Concat</code> Block.</li> <li>Provide an empty list and a non-empty list: <code>[]</code> and <code>[1, 2, 3]</code>.</li> <li>The Block will output: <code>[1, 2, 3]</code>, as the empty list does not affect the result.</li> </ul>"},{"location":"block-reference/Concat/#error-handling","title":"Error Handling","text":"<ul> <li>The <code>Concat</code> Block expects both inputs to be of the same type (either both lists or both strings). If the types do not match (e.g., concatenating a string with a list), the Block will raise a <code>TypeError</code>.</li> <li>If the inputs are neither lists nor strings, the Block may raise an error or behave unexpectedly.</li> </ul>"},{"location":"block-reference/Concat/#faq","title":"FAQ","text":"What happens if one of the inputs is empty? <p>If one of the inputs is an empty list or string, the Block will simply return the non-empty input as the result. For example, concatenating <code>\"Hello, \"</code> with an empty string will return <code>\"Hello, \"</code>.</p> Can I concatenate different types, like a string and a list? <p>No, the <code>Concat</code> Block requires both inputs to be of the same type. Attempting to concatenate a string and a list will result in a <code>TypeError</code>. Ensure that both inputs are either lists or strings.</p> Does this Block work with other sequence types like tuples? <p>No, the <code>Concat</code> Block is designed to work specifically with strings and lists. Other sequence types like tuples are not supported.</p> What happens if I concatenate very large lists or strings? <p>The <code>Concat</code> Block will handle large inputs, but performance may degrade with very large lists or strings depending on available memory and system resources.</p>"},{"location":"block-reference/Count/","title":"Count","text":""},{"location":"block-reference/Count/#overview","title":"Overview","text":"<p>The <code>Count</code> Block is designed to count the number of items in a given list. It takes a list of any type (<code>list[Any]</code>) as input and returns the number of elements in that list as an integer.</p> <p>This Block is useful when you need to know the size of a collection before proceeding with further operations.</p>"},{"location":"block-reference/Count/#description","title":"Description","text":""},{"location":"block-reference/Count/#configuration-options","title":"Configuration Options","text":"<p>No configuration options available.</p>"},{"location":"block-reference/Count/#inputs","title":"Inputs","text":"Name Data Type Description items <code>list[Any]</code>"},{"location":"block-reference/Count/#outputs","title":"Outputs","text":"Name Data Type Description output <code>int</code>"},{"location":"block-reference/Count/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/Count/#examples","title":"Example(s)","text":""},{"location":"block-reference/Count/#example-1-count-items-in-a-list","title":"Example 1: Count items in a list","text":"<ul> <li>Create a <code>Count</code> Block.</li> <li>Provide the input list: <code>[1, 2, 3, 4, 5]</code>.</li> <li>The <code>Count</code> Block will output <code>5</code>, the number of elements in the list.</li> </ul>"},{"location":"block-reference/Count/#example-2-count-items-in-a-list-of-strings","title":"Example 2: Count items in a list of strings","text":"<ul> <li>Create a <code>Count</code> Block.</li> <li>Provide the input list: <code>[\"apple\", \"banana\", \"cherry\"]</code>.</li> <li>The output will be <code>3</code> since there are three items in the list.</li> </ul>"},{"location":"block-reference/Count/#example-3-handle-an-empty-list","title":"Example 3: Handle an empty list","text":"<ul> <li>Set up a <code>Count</code> Block.</li> <li>Provide an empty list as input: <code>[]</code>.</li> <li>The <code>Count</code> Block will return <code>0</code> as there are no items in the list.</li> </ul>"},{"location":"block-reference/Count/#error-handling","title":"Error Handling","text":"<ul> <li>The <code>Count</code> Block expects a list as input. If an invalid type (e.g., a non-list) is provided, the behavior may be undefined or raise an error.</li> <li>An empty list will result in an output of <code>0</code>.</li> </ul>"},{"location":"block-reference/Count/#faq","title":"FAQ","text":"What happens if the input is not a list? <p>The <code>Count</code> Block expects a list as input. If a non-list type is provided, it may raise an error or result in undefined behavior. Ensure the input is a valid list.</p> Can I use the <code>Count</code> Block to count elements in a nested list? <p>No, the <code>Count</code> Block will return the count of the top-level items in the list. It will not recursively count elements inside nested lists.</p> What happens if the list contains mixed data types? <p>The <code>Count</code> Block can handle lists with mixed data types. It simply counts the number of items regardless of their types.</p>"},{"location":"block-reference/CreateList/","title":"CreateList","text":""},{"location":"block-reference/CreateList/#overview","title":"Overview","text":"<p>The <code>CreateList</code> Block creates a list from the provided items. This is useful when you need to build a list dynamically from multiple inputs.</p>"},{"location":"block-reference/CreateList/#description","title":"Description","text":"<p>Takes in inputs and creates a list containing the inputs</p>"},{"location":"block-reference/CreateList/#metadata","title":"Metadata","text":"<ul> <li>Category: Misc</li> </ul>"},{"location":"block-reference/CreateList/#configuration-options","title":"Configuration Options","text":"<p>No configuration options available.</p>"},{"location":"block-reference/CreateList/#inputs","title":"Inputs","text":"<p>No inputs available.</p>"},{"location":"block-reference/CreateList/#outputs","title":"Outputs","text":"Name Data Type Description list <code>list[Any]</code>"},{"location":"block-reference/CreateList/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/CreateList/#examples","title":"Example(s)","text":""},{"location":"block-reference/CreateList/#example-1-create-a-list-from-items","title":"Example 1: Create a list from items","text":"<ul> <li>Create a <code>CreateList</code> Block.</li> <li>Provide inputs: <code>1, 2, 3</code>.</li> <li>The Block will output: <code>[1, 2, 3]</code>.</li> </ul>"},{"location":"block-reference/CreateList/#error-handling","title":"Error Handling","text":"<ul> <li>The Block will raise an error if the inputs cannot be converted to a list.</li> </ul>"},{"location":"block-reference/CreateList/#faq","title":"FAQ","text":"What happens if no items are provided? <p>The Block will return an empty list if no items are provided.</p>"},{"location":"block-reference/CreateObject/","title":"CreateObject","text":""},{"location":"block-reference/CreateObject/#overview","title":"Overview","text":"<p>The <code>CreateObject</code> Block constructs an object (dictionary) from the given key-value pairs. This is useful when you need to dynamically build an object with properties.</p>"},{"location":"block-reference/CreateObject/#description","title":"Description","text":"<p>Takes in inputs and creates an object containing the inputs</p>"},{"location":"block-reference/CreateObject/#metadata","title":"Metadata","text":"<ul> <li>Category: Misc</li> </ul>"},{"location":"block-reference/CreateObject/#configuration-options","title":"Configuration Options","text":"<p>No configuration options available.</p>"},{"location":"block-reference/CreateObject/#inputs","title":"Inputs","text":"<p>No inputs available.</p>"},{"location":"block-reference/CreateObject/#outputs","title":"Outputs","text":"Name Data Type Description object <code>dict[(str, Any)]</code>"},{"location":"block-reference/CreateObject/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/CreateObject/#examples","title":"Example(s)","text":""},{"location":"block-reference/CreateObject/#example-1-create-an-object-from-properties","title":"Example 1: Create an object from properties","text":"<ul> <li>Create a <code>CreateObject</code> Block.</li> <li>Provide inputs: <code>{\"name\": \"John\", \"age\": 30}</code>.</li> <li>The Block will output: <code>{\"name\": \"John\", \"age\": 30}</code>.</li> </ul>"},{"location":"block-reference/CreateObject/#error-handling","title":"Error Handling","text":"<ul> <li>The Block assumes that all provided inputs are valid key-value pairs.</li> </ul>"},{"location":"block-reference/CreateObject/#faq","title":"FAQ","text":"Can I create an object with nested properties? <p>Yes, you can include nested objects within the properties.</p>"},{"location":"block-reference/CreateResponseWithSources/","title":"CreateResponseWithSources","text":""},{"location":"block-reference/CreateResponseWithSources/#overview","title":"Overview","text":"<p>The <code>CreateResponseWithSources</code> Block is used to generate an API response that includes both the content and associated sources. This is particularly useful when you want to return content along with references to the sources from which the information was derived.</p> <p>This Block ensures that sources are appropriately formatted, allowing them to be provided either as a list of <code>Source</code> objects or as a single URI string.</p>"},{"location":"block-reference/CreateResponseWithSources/#description","title":"Description","text":""},{"location":"block-reference/CreateResponseWithSources/#metadata","title":"Metadata","text":"<ul> <li>Category: Misc</li> </ul>"},{"location":"block-reference/CreateResponseWithSources/#configuration-options","title":"Configuration Options","text":"<p>No configuration options available.</p>"},{"location":"block-reference/CreateResponseWithSources/#inputs","title":"Inputs","text":"Name Data Type Description content <code>Any</code> sources <code>list[Source] or str or Constant(value=None)</code>"},{"location":"block-reference/CreateResponseWithSources/#outputs","title":"Outputs","text":"Name Data Type Description response <code>ApiResponse</code>"},{"location":"block-reference/CreateResponseWithSources/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/CreateResponseWithSources/#examples","title":"Example(s)","text":""},{"location":"block-reference/CreateResponseWithSources/#example-1-create-a-response-with-a-list-of-sources","title":"Example 1: Create a response with a list of sources","text":"<ul> <li>Create a <code>CreateResponseWithSources</code> Block.</li> <li>Provide content such as <code>\"Here is the summary of the report.\"</code> and a list of sources: <code>[Source(index=1, uri=\"https://example.com/source1\"), Source(index=2, uri=\"https://example.com/source2\")]</code>.</li> <li>The Block will emit an API response containing the content and the list of sources.</li> </ul>"},{"location":"block-reference/CreateResponseWithSources/#example-2-create-a-response-with-a-single-source-uri","title":"Example 2: Create a response with a single source URI","text":"<ul> <li>Set up a <code>CreateResponseWithSources</code> Block.</li> <li>Provide content: <code>\"This is the generated content.\"</code> and a single source URI: <code>\"https://example.com/source\"</code>.</li> <li>The Block will convert the URI into a <code>Source</code> object and output the response with the source.</li> </ul>"},{"location":"block-reference/CreateResponseWithSources/#example-3-create-a-response-without-any-sources","title":"Example 3: Create a response without any sources","text":"<ul> <li>Create a <code>CreateResponseWithSources</code> Block.</li> <li>Provide content: <code>\"Content without sources.\"</code> and no sources.</li> <li>The Block will output the content with an empty sources array.</li> </ul>"},{"location":"block-reference/CreateResponseWithSources/#error-handling","title":"Error Handling","text":"<ul> <li>If the sources input is a string, the Block will automatically convert it into a <code>Source</code> object with the default index of <code>1</code>.</li> <li>If no sources are provided, the Block will send an empty list as the <code>sources</code> field in the response.</li> </ul>"},{"location":"block-reference/CreateResponseWithSources/#faq","title":"FAQ","text":"What happens if I provide a string instead of a list of sources? <p>If a single string is provided, the Block will convert the string into a <code>Source</code> object with an index of <code>1</code> and include it in the response.</p> Can I create a response without any sources? <p>Yes, if no sources are provided, the Block will generate a response with an empty list for the <code>sources</code> field.</p> Does this Block handle non-string content? <p>Yes, the Block automatically converts non-string content (e.g., dictionaries) into a JSON string using <code>json.dumps()</code> before sending it in the response.</p>"},{"location":"block-reference/First/","title":"First","text":""},{"location":"block-reference/First/#overview","title":"Overview","text":"<p>The <code>First</code> Block retrieves the first item from a given list. It takes a list of any type as input and outputs the first element. If the list is empty, it may raise an error due to attempting to access an index that does not exist.</p> <p>This Block is useful when you need to quickly access the first item in a list for further processing.</p>"},{"location":"block-reference/First/#description","title":"Description","text":"<p>Gets the first item from a list</p>"},{"location":"block-reference/First/#metadata","title":"Metadata","text":"<ul> <li>Category: Function</li> </ul>"},{"location":"block-reference/First/#configuration-options","title":"Configuration Options","text":"<p>No configuration options available.</p>"},{"location":"block-reference/First/#inputs","title":"Inputs","text":"Name Data Type Description items <code>list[firstItemT]</code>"},{"location":"block-reference/First/#outputs","title":"Outputs","text":"Name Data Type Description item <code>firstItemT</code>"},{"location":"block-reference/First/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/First/#examples","title":"Example(s)","text":""},{"location":"block-reference/First/#example-1-get-the-first-item-in-a-list-of-numbers","title":"Example 1: Get the first item in a list of numbers","text":"<ul> <li>Create a <code>First</code> Block.</li> <li>Provide the input list: <code>[10, 20, 30]</code>.</li> <li>The Block will output <code>10</code>, the first element in the list.</li> </ul>"},{"location":"block-reference/First/#example-2-get-the-first-item-in-a-list-of-strings","title":"Example 2: Get the first item in a list of strings","text":"<ul> <li>Set up a <code>First</code> Block.</li> <li>Provide the input list: <code>[\"apple\", \"banana\", \"cherry\"]</code>.</li> <li>The Block will output <code>\"apple\"</code>, the first string in the list.</li> </ul>"},{"location":"block-reference/First/#example-3-handle-an-empty-list","title":"Example 3: Handle an empty list","text":"<ul> <li>Create a <code>First</code> Block.</li> <li>Provide an empty list: <code>[]</code>.</li> <li>The Block will raise an error since there is no first item to return.</li> </ul>"},{"location":"block-reference/First/#error-handling","title":"Error Handling","text":"<ul> <li>The <code>First</code> Block will raise an <code>IndexError</code> if the input list is empty. Ensure that the list contains at least one item before using this Block.</li> <li>The Block assumes that the input is a valid list. If the input is not a list, it may result in undefined behavior or raise an error.</li> </ul>"},{"location":"block-reference/First/#faq","title":"FAQ","text":"What happens if the list is empty? <p>If the list is empty, the <code>First</code> Block will raise an <code>IndexError</code> because there is no item at index <code>0</code>. You should ensure that the list contains at least one item before using the Block.</p> Can I use the <code>First</code> Block with different data types in the list? <p>Yes, the <code>First</code> Block works with lists containing any data type. It will return the first item, regardless of its type.</p> What if I want to return the first item safely without an error? <p>To avoid errors when the list is empty, you can add a check before using the <code>First</code> Block. Alternatively, you can modify the Block to return <code>None</code> or a default value if the list is empty.</p>"},{"location":"block-reference/Flatten/","title":"Flatten","text":""},{"location":"block-reference/Flatten/#overview","title":"Overview","text":"<p>The <code>Flatten</code> Block takes a list of lists and flattens it into a single list. It iterates through each sublist and merges all the elements into a single list, removing one level of nesting.</p> <p>This Block is useful for simplifying nested list structures, making it easier to work with a single list of elements.</p>"},{"location":"block-reference/Flatten/#description","title":"Description","text":"<p>Flattens a list of lists into a single list</p>"},{"location":"block-reference/Flatten/#metadata","title":"Metadata","text":"<ul> <li>Category: Function</li> </ul>"},{"location":"block-reference/Flatten/#configuration-options","title":"Configuration Options","text":"<p>No configuration options available.</p>"},{"location":"block-reference/Flatten/#inputs","title":"Inputs","text":"Name Data Type Description lists <code>list[list[Any]]</code>"},{"location":"block-reference/Flatten/#outputs","title":"Outputs","text":"Name Data Type Description list <code>list[Any]</code>"},{"location":"block-reference/Flatten/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/Flatten/#examples","title":"Example(s)","text":""},{"location":"block-reference/Flatten/#example-1-flatten-a-list-of-lists-of-numbers","title":"Example 1: Flatten a list of lists of numbers","text":"<ul> <li>Create a <code>Flatten</code> Block.</li> <li>Provide the input: <code>[[1, 2], [3, 4], [5, 6]]</code>.</li> <li>The Block will output <code>[1, 2, 3, 4, 5, 6]</code>, merging all elements into a single list.</li> </ul>"},{"location":"block-reference/Flatten/#example-2-flatten-a-list-of-mixed-data-types","title":"Example 2: Flatten a list of mixed data types","text":"<ul> <li>Set up a <code>Flatten</code> Block.</li> <li>Provide the input: <code>[['apple', 'banana'], ['cherry'], ['date', 'fig']]</code>.</li> <li>The output will be <code>['apple', 'banana', 'cherry', 'date', 'fig']</code>, flattening all the sublists into one.</li> </ul>"},{"location":"block-reference/Flatten/#example-3-handle-an-empty-list-of-lists","title":"Example 3: Handle an empty list of lists","text":"<ul> <li>Create a <code>Flatten</code> Block.</li> <li>Provide an empty list of lists: <code>[]</code>.</li> <li>The output will be an empty list: <code>[]</code>.</li> </ul>"},{"location":"block-reference/Flatten/#error-handling","title":"Error Handling","text":"<ul> <li>The <code>Flatten</code> Block assumes that the input is a valid list of lists. If the input is not structured as expected (e.g., contains non-list elements), it may raise an error or result in undefined behavior.</li> <li>If any sublist is <code>None</code>, it will result in an error when trying to flatten the list. Ensure all sublists are properly structured.</li> </ul>"},{"location":"block-reference/Flatten/#faq","title":"FAQ","text":"What happens if one of the sublists is empty? <p>If a sublist is empty, the <code>Flatten</code> Block will skip over it and continue processing the other sublists. For example, flattening <code>[[1, 2], [], [3, 4]]</code> will result in <code>[1, 2, 3, 4]</code>.</p> Can I flatten lists with different data types? <p>Yes, the <code>Flatten</code> Block works with lists containing mixed data types. It will merge all elements, regardless of their types, into a single list.</p> What happens if the input list contains non-list elements? <p>The <code>Flatten</code> Block expects the input to be a list of lists. If non-list elements are included at the top level, the Block may raise an error or behave unexpectedly. Ensure the input is properly formatted as a list of lists.</p> What if my input list has more than two levels of nesting? <p>The <code>Flatten</code> Block only flattens the list by one level. If you have multiple levels of nested lists (e.g., <code>[[[1, 2]], [[3, 4]]]</code>), you'll need to apply the <code>Flatten</code> Block multiple times or use a different approach to fully flatten the structure.</p>"},{"location":"block-reference/ForEach/","title":"ForEach","text":""},{"location":"block-reference/ForEach/#overview","title":"Overview","text":"<p>The <code>ForEach</code> Block is used to loop through a list of items and output each item one at a time. It takes a list of any type (<code>list[ItemT]</code>) as input, and for each item in the list, it sends the item through an output channel. Once all items are processed, the output channel is closed.</p> <p>This Block is ideal for cases where items need to be processed individually rather than in a batch.</p>"},{"location":"block-reference/ForEach/#description","title":"Description","text":"<p>Loops through a list of items and outputs them one at a time</p>"},{"location":"block-reference/ForEach/#metadata","title":"Metadata","text":"<ul> <li>Category: Function</li> </ul>"},{"location":"block-reference/ForEach/#configuration-options","title":"Configuration Options","text":"<p>No configuration options available.</p>"},{"location":"block-reference/ForEach/#inputs","title":"Inputs","text":"Name Data Type Description items <code>list[ItemT]</code>"},{"location":"block-reference/ForEach/#outputs","title":"Outputs","text":"Name Data Type Description item <code>OutputChannel[ItemT]</code>"},{"location":"block-reference/ForEach/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/ForEach/#examples","title":"Example(s)","text":""},{"location":"block-reference/ForEach/#example-1-loop-through-a-list-of-numbers","title":"Example 1: Loop through a list of numbers","text":"<ul> <li>Create a <code>ForEach</code> Block.</li> <li>Provide the input list: <code>[10, 20, 30]</code>.</li> <li>The <code>ForEach</code> Block will output each number (<code>10</code>, <code>20</code>, <code>30</code>) one at a time.</li> </ul>"},{"location":"block-reference/ForEach/#example-2-process-a-list-of-strings","title":"Example 2: Process a list of strings","text":"<ul> <li>Set up a <code>ForEach</code> Block.</li> <li>Provide a list of strings: <code>[\"apple\", \"banana\", \"cherry\"]</code>.</li> <li>The Block will output each string individually as <code>\"apple\"</code>, <code>\"banana\"</code>, and <code>\"cherry\"</code>.</li> </ul>"},{"location":"block-reference/ForEach/#example-3-handle-an-empty-list","title":"Example 3: Handle an empty list","text":"<ul> <li>Create a <code>ForEach</code> Block.</li> <li>Provide an empty list: <code>[]</code>.</li> <li>Since the list is empty, the Block will not output any items but will close the channel immediately.</li> </ul>"},{"location":"block-reference/ForEach/#error-handling","title":"Error Handling","text":"<ul> <li>The <code>ForEach</code> Block expects a list as input. If the provided input is not a list, it may result in undefined behavior or errors.</li> <li>If the list is empty, the Block will simply close the output channel without sending any items.</li> </ul>"},{"location":"block-reference/ForEach/#faq","title":"FAQ","text":"What happens if the list is empty? <p>If the list is empty, the <code>ForEach</code> Block will not send any items and will immediately close the output channel.</p> Can I use the <code>ForEach</code> Block with asynchronous operations? <p>The <code>ForEach</code> Block can send items through an output channel, which can then be consumed by other blocks that handle asynchronous operations. However, the <code>ForEach</code> Block itself does not perform any asynchronous processing on the items.</p> Can I use the <code>ForEach</code> Block with nested lists? <p>The <code>ForEach</code> Block will treat each item in the list as an individual item, even if the item itself is a list. To iterate over nested lists, additional logic may be needed.</p>"},{"location":"block-reference/Get/","title":"Get","text":""},{"location":"block-reference/Get/#overview","title":"Overview","text":"<p>The <code>Get</code> Block extracts data from a JSON object or list using a JSONPath expression. JSONPath is a query language for navigating and extracting elements from JSON structures. This implementation uses the <code>jsonpath-ng</code> library from PyPI.</p> <p>You can configure the JSONPath expression via the <code>path</code> parameter, and the Block will return the extracted data based on that path.</p>"},{"location":"block-reference/Get/#description","title":"Description","text":"<p>Uses JSONPath to extract data from a JSON object or list. JSONPath implementation is from https://pypi.org/project/jsonpath-ng/</p>"},{"location":"block-reference/Get/#metadata","title":"Metadata","text":"<ul> <li>Category: Function</li> </ul>"},{"location":"block-reference/Get/#configuration-options","title":"Configuration Options","text":"Name Data Type Description Default Value path <code>str</code>"},{"location":"block-reference/Get/#inputs","title":"Inputs","text":"Name Data Type Description data <code>list[Any] or dict[(str, Any)]</code>"},{"location":"block-reference/Get/#outputs","title":"Outputs","text":"Name Data Type Description result <code>Any</code>"},{"location":"block-reference/Get/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/Get/#examples","title":"Example(s)","text":""},{"location":"block-reference/Get/#example-1-extract-a-field-from-a-json-object","title":"Example 1: Extract a field from a JSON object","text":"<ul> <li>Create a <code>Get</code> Block.</li> <li>Set the <code>path</code> to <code>$.name</code> (this JSONPath expression extracts the \"name\" field).</li> <li>Provide the input JSON object: <code>{\"name\": \"John\", \"age\": 30}</code>.</li> <li>The Block will output <code>\"John\"</code>, extracting the \"name\" field.</li> </ul>"},{"location":"block-reference/Get/#example-2-extract-multiple-fields-from-a-list-of-json-objects","title":"Example 2: Extract multiple fields from a list of JSON objects","text":"<ul> <li>Set up a <code>Get</code> Block.</li> <li>Set the <code>path</code> to <code>$[*].name</code> (this JSONPath expression extracts the \"name\" field from all objects in the list).</li> <li>Provide the input JSON list: <code>[{\"name\": \"John\"}, {\"name\": \"Jane\"}]</code>.</li> <li>The Block will output <code>[\"John\", \"Jane\"]</code>.</li> </ul>"},{"location":"block-reference/Get/#example-3-handle-nested-fields-in-a-complex-json-structure","title":"Example 3: Handle nested fields in a complex JSON structure","text":"<ul> <li>Create a <code>Get</code> Block.</li> <li>Set the <code>path</code> to <code>$.address.city</code>.</li> <li>Provide the input: <code>{\"address\": {\"city\": \"Auckland\", \"postcode\": \"1010\"}}</code>.</li> <li>The Block will output <code>\"Auckland\"</code>, extracting the \"city\" field from the nested \"address\" object.</li> </ul>"},{"location":"block-reference/Get/#error-handling","title":"Error Handling","text":"<ul> <li>If the <code>path</code> is not a valid JSONPath expression, the Block will raise an error.</li> <li>If no match is found for the JSONPath, the Block will return <code>None</code> for individual JSON objects or an empty list for lists.</li> <li>Ensure the input JSON is well-formed; otherwise, the Block may raise an error.</li> </ul>"},{"location":"block-reference/Get/#faq","title":"FAQ","text":"What happens if the JSONPath expression doesn't match any field? <p>If the JSONPath expression does not match any field in the input, the Block will return <code>None</code> for a single JSON object and an empty list for a list of JSON objects.</p> Can I use this Block for both JSON objects and lists? <p>Yes, the <code>Get</code> Block supports both JSON objects and lists. For lists, it will return all matching fields as a list of values. For single JSON objects, it will return the first match or <code>None</code> if no match is found.</p> How does the Block handle nested fields? <p>The <code>Get</code> Block uses JSONPath expressions to navigate and extract fields from nested JSON structures. By specifying the correct path, you can extract deeply nested fields from JSON objects.</p> What happens if multiple matches are found? <p>For lists, the <code>Get</code> Block will return all matching elements. For a single JSON object, the Block returns only the first match found. If you need all matches from an object, you should ensure the input is structured as a list.</p>"},{"location":"block-reference/GetAllDocuments/","title":"GetAllDocuments","text":""},{"location":"block-reference/GetAllDocuments/#overview","title":"Overview","text":"<p>The <code>GetAllDocuments</code> Block retrieves all documents from a specified data space using a <code>SearchService</code>. This Block is useful when you need to gather and process a collection of documents stored in a data space for analysis or further operations.</p>"},{"location":"block-reference/GetAllDocuments/#description","title":"Description","text":""},{"location":"block-reference/GetAllDocuments/#metadata","title":"Metadata","text":"<ul> <li>Category: Data</li> </ul>"},{"location":"block-reference/GetAllDocuments/#configuration-options","title":"Configuration Options","text":"Name Data Type Description Default Value dataspace_id <code>str</code>"},{"location":"block-reference/GetAllDocuments/#inputs","title":"Inputs","text":"Name Data Type Description run <code>Any</code>"},{"location":"block-reference/GetAllDocuments/#outputs","title":"Outputs","text":"Name Data Type Description documents <code>list[GetAllDocumentsResult]</code>"},{"location":"block-reference/GetAllDocuments/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/GetAllDocuments/#examples","title":"Example(s)","text":""},{"location":"block-reference/GetAllDocuments/#example-1-retrieve-all-documents-from-a-data-space","title":"Example 1: Retrieve all documents from a data space","text":"<ul> <li>Create a <code>GetAllDocuments</code> Block.</li> <li>Set the <code>dataspace_id</code> to the ID of the data space you want to retrieve documents from.</li> <li>The Block will return a list of documents, each containing the document path and content.</li> </ul>"},{"location":"block-reference/GetAllDocuments/#example-2-use-in-a-workflow-to-process-documents","title":"Example 2: Use in a workflow to process documents","text":"<ul> <li>Set up a <code>GetAllDocuments</code> Block in a workflow.</li> <li>Provide the <code>dataspace_id</code> to specify the data space.</li> <li>After retrieving the documents, pass them to another block for processing, such as content analysis or text summarization.</li> </ul>"},{"location":"block-reference/GetAllDocuments/#error-handling","title":"Error Handling","text":"<ul> <li>If the <code>dataspace_id</code> is invalid or the data space cannot be accessed, the Block will raise an error.</li> <li>If no documents are found in the data space, the Block will return an empty list.</li> </ul>"},{"location":"block-reference/GetAllDocuments/#faq","title":"FAQ","text":"What happens if the data space is empty? <p>If the specified data space contains no documents, the Block will return an empty list.</p> Can I use this Block with different data spaces? <p>Yes, you can use this Block with any data space by setting the <code>dataspace_id</code> to the appropriate ID for the space you want to access.</p> How are the documents formatted in the output? <p>The Block outputs a list of <code>GetAllDocumentsResult</code> objects, each containing the <code>path</code> (the document's location) and <code>content</code> (the text of the document).</p>"},{"location":"block-reference/GetFileContent/","title":"GetFileContent","text":""},{"location":"block-reference/GetFileContent/#overview","title":"Overview","text":"<p>The <code>GetFileContent</code> Block extracts text content from a file by determining its type and applying the appropriate extraction method. It supports PDF and other file types, providing a seamless way to handle document files and retrieve their text content.</p> <p>The block interacts with a <code>BlobService</code> to retrieve file data from a URI and processes the content based on the detected file type.</p>"},{"location":"block-reference/GetFileContent/#description","title":"Description","text":""},{"location":"block-reference/GetFileContent/#metadata","title":"Metadata","text":"<ul> <li>Category: Data</li> </ul>"},{"location":"block-reference/GetFileContent/#configuration-options","title":"Configuration Options","text":"<p>No configuration options available.</p>"},{"location":"block-reference/GetFileContent/#inputs","title":"Inputs","text":"Name Data Type Description file <code>File</code>"},{"location":"block-reference/GetFileContent/#outputs","title":"Outputs","text":"Name Data Type Description content <code>str</code> file_name <code>str</code>"},{"location":"block-reference/GetFileContent/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/GetFileContent/#examples","title":"Example(s)","text":""},{"location":"block-reference/GetFileContent/#example-1-extract-text-from-a-pdf-file","title":"Example 1: Extract text from a PDF file","text":"<ul> <li>Create a <code>GetFileContent</code> Block.</li> <li>Provide a PDF file via a <code>File</code> object.</li> <li>The Block will extract the text from the PDF file and output the text content, as well as the file name.</li> </ul>"},{"location":"block-reference/GetFileContent/#example-2-extract-text-from-a-non-pdf-file","title":"Example 2: Extract text from a non-PDF file","text":"<ul> <li>Set up a <code>GetFileContent</code> Block.</li> <li>Provide a text or other non-PDF file via a <code>File</code> object.</li> <li>The Block will extract and convert the text content using the appropriate method and send it to the <code>content</code> output, along with the file name.</li> </ul>"},{"location":"block-reference/GetFileContent/#error-handling","title":"Error Handling","text":"<ul> <li>If the file type is not detected or cannot be processed, the Block will raise an error.</li> <li>PDF text extraction may be slower for large or complex documents due to the nature of the PDF structure.</li> <li>If no file name is available, an empty string will be sent to the <code>file_name</code> output.</li> </ul>"},{"location":"block-reference/GetFileContent/#faq","title":"FAQ","text":"What file types are supported? <p>This Block supports PDF files and other file types that can be partitioned and converted to text. It uses specialized methods for extracting text from PDFs and more general methods for other file types.</p> What happens if the file type cannot be detected? <p>If the file type cannot be detected, the Block will use a fallback method to handle the file, or it will raise an error if the file type is unsupported.</p> How does PDF text extraction work? <p>PDF text extraction uses the <code>pypdf</code> library to extract text from each page. The extracted text is then combined into a single string separated by double newlines for readability.</p> Can I use this block for large files? <p>Yes, but be aware that PDF text extraction can be slow for large or complex documents. For large files, consider handling the text extraction asynchronously to avoid blocking workflows.</p>"},{"location":"block-reference/GetJsonField/","title":"GetJsonField","text":""},{"location":"block-reference/GetJsonField/#overview","title":"Overview","text":"<p>The <code>GetJsonField</code> Block uses JSONPath to extract specific data from a JSON object or list. JSONPath is a query language used to traverse and extract data from JSON structures. This Block is marked as obsolete, meaning it may no longer be recommended for use in future workflows.</p> <p>It accepts JSON input, which can be a JSON object or a list of JSON objects, and applies a JSONPath expression to extract the specified fields.</p>"},{"location":"block-reference/GetJsonField/#description","title":"Description","text":"<p>Uses JSONPath to extract data from a JSON object or list</p>"},{"location":"block-reference/GetJsonField/#metadata","title":"Metadata","text":"<ul> <li>Category: Function</li> <li>Obsolete: True</li> </ul>"},{"location":"block-reference/GetJsonField/#configuration-options","title":"Configuration Options","text":"Name Data Type Description Default Value json_field_structure <code>str</code>"},{"location":"block-reference/GetJsonField/#inputs","title":"Inputs","text":"Name Data Type Description json_object <code>Any</code>"},{"location":"block-reference/GetJsonField/#outputs","title":"Outputs","text":"Name Data Type Description field <code>Any</code>"},{"location":"block-reference/GetJsonField/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/GetJsonField/#examples","title":"Example(s)","text":""},{"location":"block-reference/GetJsonField/#example-1-extract-a-field-from-a-json-object","title":"Example 1: Extract a field from a JSON object","text":"<ul> <li>Create a <code>GetJsonField</code> Block.</li> <li>Set the <code>json_field_structure</code> to <code>$.name</code> (this JSONPath expression extracts the \"name\" field).</li> <li>Provide the input JSON object: <code>{\"name\": \"John\", \"age\": 30}</code>.</li> <li>The Block will output <code>[\"John\"]</code>, extracting the \"name\" field.</li> </ul>"},{"location":"block-reference/GetJsonField/#example-2-extract-multiple-fields-from-a-list-of-json-objects","title":"Example 2: Extract multiple fields from a list of JSON objects","text":"<ul> <li>Set up a <code>GetJsonField</code> Block.</li> <li>Set the <code>json_field_structure</code> to <code>$[*].name</code> (this JSONPath expression extracts the \"name\" field from all objects in the list).</li> <li>Provide the input JSON list: <code>[{\"name\": \"John\"}, {\"name\": \"Jane\"}]</code>.</li> <li>The Block will output <code>[\"John\", \"Jane\"]</code>.</li> </ul>"},{"location":"block-reference/GetJsonField/#example-3-handle-nested-fields-in-a-complex-json-structure","title":"Example 3: Handle nested fields in a complex JSON structure","text":"<ul> <li>Create a <code>GetJsonField</code> Block.</li> <li>Set the <code>json_field_structure</code> to <code>$.address.city</code>.</li> <li>Provide the input: <code>{\"address\": {\"city\": \"Auckland\", \"postcode\": \"1010\"}}</code>.</li> <li>The Block will output <code>[\"Auckland\"]</code>, extracting the \"city\" field from the nested \"address\" object.</li> </ul>"},{"location":"block-reference/GetJsonField/#error-handling","title":"Error Handling","text":"<ul> <li>If the <code>json_field_structure</code> is not a valid JSONPath expression, the Block will raise an error.</li> <li>If the JSON object or list does not contain the field specified by the JSONPath, the Block will return an empty list.</li> <li>If the input JSON is malformed or not valid, an error will be raised.</li> </ul>"},{"location":"block-reference/GetJsonField/#faq","title":"FAQ","text":"What happens if the JSONPath expression doesn't match any field? <p>If the JSONPath expression doesn't match any field in the input JSON, the Block will return an empty list. Ensure the JSONPath expression is correct for the structure of the input JSON.</p> Can this Block handle both JSON objects and lists? <p>Yes, the <code>GetJsonField</code> Block works with both individual JSON objects and lists of JSON objects. It will apply the JSONPath expression to extract the relevant fields from either structure.</p> What does it mean that this Block is obsolete? <p>The <code>GetJsonField</code> Block has been marked as obsolete, meaning it may no longer be recommended for use in new workflows and could be removed in future updates. It's advisable to explore alternative methods for extracting JSON fields.</p> How does the Block handle complex nested JSON structures? <p>The <code>GetJsonField</code> Block can handle complex nested JSON structures by using appropriate JSONPath expressions. For example, you can extract deeply nested fields by specifying the correct path in the <code>json_field_structure</code>.</p>"},{"location":"block-reference/HTTPRequest/","title":"HTTPRequest","text":""},{"location":"block-reference/HTTPRequest/#overview","title":"Overview","text":"<p>The <code>HTTPRequest</code> Block performs HTTP requests using methods such as GET, POST, PUT, DELETE, and PATCH. It supports passing request parameters, headers, query parameters, and request bodies. The Block outputs a <code>ResponseObject</code> containing the response content, headers, body, and status code.</p> <p>By default, the request method is <code>GET</code>, but it can be configured using the available HTTP methods. If any values are not provided during the request, they will be fetched from the Block's configuration.</p>"},{"location":"block-reference/HTTPRequest/#description","title":"Description","text":"<p>Performs HTTP requests such as GET, POST, PUT, DELETE, and more.</p>"},{"location":"block-reference/HTTPRequest/#metadata","title":"Metadata","text":"<ul> <li>Category: Function</li> </ul>"},{"location":"block-reference/HTTPRequest/#configuration-options","title":"Configuration Options","text":"Name Data Type Description Default Value timeout <code>int</code> <code>30</code> method <code>HTTPMethod</code> <code>GET</code> url <code>str</code> headers <code>dict[(str, Any)] or Constant(value=None)</code> query_params <code>dict[(str, Any)] or Constant(value=None)</code> body <code>dict[(str, Any)] or Constant(value=None)</code>"},{"location":"block-reference/HTTPRequest/#inputs","title":"Inputs","text":"Name Data Type Description request <code>RequestObject</code> Can accept request parameters (method, url, headers, query_params, and/or body). Any values not specified will use the Config values. Pass an empty dict ({}) to use all Config values"},{"location":"block-reference/HTTPRequest/#outputs","title":"Outputs","text":"Name Data Type Description response <code>ResponseObject</code>"},{"location":"block-reference/HTTPRequest/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/HTTPRequest/#examples","title":"Example(s)","text":""},{"location":"block-reference/HTTPRequest/#example-1-perform-a-get-request","title":"Example 1: Perform a GET request","text":"<ul> <li>Create an <code>HTTPRequest</code> Block.</li> <li>Set the <code>url</code> to <code>\"https://api.example.com/data\"</code>.</li> <li>Leave the method as <code>GET</code>.</li> <li>The Block will send a <code>GET</code> request to the provided URL and output the response, including the content, headers, and status code.</li> </ul>"},{"location":"block-reference/HTTPRequest/#example-2-perform-a-post-request-with-a-json-body","title":"Example 2: Perform a POST request with a JSON body","text":"<ul> <li>Set up an <code>HTTPRequest</code> Block.</li> <li>Set the <code>method</code> to <code>POST</code>.</li> <li>Set the <code>url</code> to <code>\"https://api.example.com/create\"</code>.</li> <li>Provide a body such as <code>{\"name\": \"John\", \"age\": 30}</code>.</li> <li>The Block will send the <code>POST</code> request and return the response with the created data.</li> </ul>"},{"location":"block-reference/HTTPRequest/#example-3-handle-request-headers-and-query-parameters","title":"Example 3: Handle request headers and query parameters","text":"<ul> <li>Create an <code>HTTPRequest</code> Block.</li> <li>Set the <code>url</code> to <code>\"https://api.example.com/data\"</code>.</li> <li>Add headers like <code>{\"Authorization\": \"Bearer token123\"}</code>.</li> <li>Add query parameters such as <code>{\"page\": 1, \"limit\": 10}</code>.</li> <li>The Block will send a <code>GET</code> request with the headers and query parameters and return the response.</li> </ul>"},{"location":"block-reference/HTTPRequest/#error-handling","title":"Error Handling","text":"<ul> <li>If the <code>URL</code> is missing, the Block will raise a <code>ValueError</code> indicating that the URL is required.</li> <li>Network-related errors will raise an <code>HTTPError</code> with a descriptive message, e.g., \"Network error occurred\".</li> <li>If the server responds with an HTTP error (status code 4xx or 5xx), an <code>HTTPError</code> will be raised with the corresponding <code>ResponseObject</code>.</li> <li>Any other unexpected exceptions will also raise an <code>HTTPError</code>.</li> </ul>"},{"location":"block-reference/HTTPRequest/#faq","title":"FAQ","text":"What happens if no method is provided? <p>If no method is provided in the request or configuration, the Block will default to the <code>GET</code> method for the request.</p> Can I use this Block for asynchronous requests? <p>Yes, the <code>HTTPRequest</code> Block is designed for asynchronous requests. It uses the <code>httpx.AsyncClient</code> to handle the HTTP calls asynchronously.</p> What happens if the response is not JSON? <p>If the response's content type is not <code>application/json</code>, the Block will still return the response content, but the <code>body</code> field in the <code>ResponseObject</code> will be <code>None</code>.</p> How can I pass headers and query parameters dynamically? <p>Headers and query parameters can be passed either through the <code>RequestObject</code> when making the request or through the Block's configuration. Any values provided in the request will override the configuration values.</p>"},{"location":"block-reference/JinjaTemplate/","title":"JinjaTemplate","text":""},{"location":"block-reference/JinjaTemplate/#overview","title":"Overview","text":"<p>The <code>JinjaTemplate</code> Block allows you to generate a string by using a template and dynamically inserting values into it. This is useful when you want to build strings based on inputs with specific formatting. It uses the jinja2 templating engine to render the template.</p>"},{"location":"block-reference/JinjaTemplate/#description","title":"Description","text":"<p>Takes in a template string and renders it with the given inputs</p>"},{"location":"block-reference/JinjaTemplate/#metadata","title":"Metadata","text":"<ul> <li>Category: Misc</li> </ul>"},{"location":"block-reference/JinjaTemplate/#configuration-options","title":"Configuration Options","text":"Name Data Type Description Default Value template <code>str</code>"},{"location":"block-reference/JinjaTemplate/#inputs","title":"Inputs","text":"<p>No inputs available.</p>"},{"location":"block-reference/JinjaTemplate/#outputs","title":"Outputs","text":"Name Data Type Description string <code>str</code>"},{"location":"block-reference/JinjaTemplate/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/JinjaTemplate/#examples","title":"Example(s)","text":""},{"location":"block-reference/JinjaTemplate/#example-1-build-a-string-with-dynamic-values","title":"Example 1: Build a string with dynamic values","text":"<ul> <li>Create a <code>JinjaTemplate</code> Block.</li> <li>Set the <code>template</code> to <code>\"Hello, {{ name }}!\"</code>.</li> <li>Provide the input: <code>{\"name\": \"John\"}</code>.</li> <li>The Block will output: <code>\"Hello, John!\"</code>.</li> </ul>"},{"location":"block-reference/JinjaTemplate/#error-handling","title":"Error Handling","text":"<ul> <li>If the template contains invalid syntax, the Block will raise an error.</li> </ul>"},{"location":"block-reference/JinjaTemplate/#faq","title":"FAQ","text":"What happens if a required input is missing? <p>The Block will raise a <code>KeyError</code> if the template expects a variable that is not provided in the inputs.</p>"},{"location":"block-reference/JoinStrings/","title":"JoinStrings","text":""},{"location":"block-reference/JoinStrings/#overview","title":"Overview","text":"<p>The <code>JoinStrings</code> Block takes a list of strings and joins them together into a single string using a configured separator. You can specify the separator to use between the strings (such as a space, comma, or other characters). The resulting string is then output.</p> <p>This Block is helpful when you need to concatenate a list of strings with a custom separator.</p>"},{"location":"block-reference/JoinStrings/#description","title":"Description","text":"<p>Joins a list of strings using the configured separator and outputs the resulting string</p>"},{"location":"block-reference/JoinStrings/#metadata","title":"Metadata","text":"<ul> <li>Category: Function</li> </ul>"},{"location":"block-reference/JoinStrings/#configuration-options","title":"Configuration Options","text":"Name Data Type Description Default Value separator <code>str</code>"},{"location":"block-reference/JoinStrings/#inputs","title":"Inputs","text":"Name Data Type Description strings <code>list[str]</code>"},{"location":"block-reference/JoinStrings/#outputs","title":"Outputs","text":"Name Data Type Description output <code>str</code>"},{"location":"block-reference/JoinStrings/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/JoinStrings/#examples","title":"Example(s)","text":""},{"location":"block-reference/JoinStrings/#example-1-join-strings-with-a-space-separator","title":"Example 1: Join strings with a space separator","text":"<ul> <li>Create a <code>JoinStrings</code> Block.</li> <li>Set the <code>separator</code> to <code>\" \"</code>.</li> <li>Provide the input list: <code>[\"apple\", \"banana\", \"cherry\"]</code>.</li> <li>The output will be <code>\"apple banana cherry\"</code>.</li> </ul>"},{"location":"block-reference/JoinStrings/#example-2-join-strings-with-a-comma","title":"Example 2: Join strings with a comma","text":"<ul> <li>Create a <code>JoinStrings</code> Block.</li> <li>Set the <code>separator</code> to <code>\",\"</code>.</li> <li>Provide the input list: <code>[\"apple\", \"banana\", \"cherry\"]</code>.</li> <li>The output will be <code>\"apple,banana,cherry\"</code>.</li> </ul>"},{"location":"block-reference/JoinStrings/#example-3-join-strings-without-a-separator","title":"Example 3: Join strings without a separator","text":"<ul> <li>Set up a <code>JoinStrings</code> Block.</li> <li>Leave the <code>separator</code> as an empty string (<code>\"\"</code>).</li> <li>Provide the input list: <code>[\"apple\", \"banana\", \"cherry\"]</code>.</li> <li>The output will be <code>\"applebananacherry\"</code>.</li> </ul>"},{"location":"block-reference/JoinStrings/#error-handling","title":"Error Handling","text":"<ul> <li>The <code>JoinStrings</code> Block expects a list of strings as input. If any item in the list is not a string, it may result in an error or undefined behavior.</li> <li>If the input list is empty, the Block will output an empty string.</li> </ul>"},{"location":"block-reference/JoinStrings/#faq","title":"FAQ","text":"What happens if the input list is empty? <p>If the input list is empty, the <code>JoinStrings</code> Block will return an empty string.</p> Can I use this block to join strings with multi-character separators? <p>Yes, you can use any string as the separator, including multi-character strings. For example, setting the separator to <code>\" - \"</code> will join the strings with a hyphen and spaces.</p> What happens if the input contains non-string items? <p>The <code>JoinStrings</code> Block expects all items in the list to be strings. If the input contains non-string items, it may raise an error or cause unexpected behavior. Ensure all items are strings before using the Block.</p>"},{"location":"block-reference/LLM/","title":"LLM","text":""},{"location":"block-reference/LLM/#overview","title":"Overview","text":"<p>The <code>LLM</code> Block facilitates interaction with a Language Learning Model (LLM) by processing user messages and generating responses. It can handle both simple string responses and structured data based on a defined schema. The block uses a <code>ModelConfig</code> to configure the LLM and supports thread history to maintain context across multiple interactions.</p>"},{"location":"block-reference/LLM/#description","title":"Description","text":""},{"location":"block-reference/LLM/#metadata","title":"Metadata","text":"<ul> <li>Category: Agent</li> </ul>"},{"location":"block-reference/LLM/#configuration-options","title":"Configuration Options","text":"Name Data Type Description Default Value use_thread_history <code>bool</code>"},{"location":"block-reference/LLM/#inputs","title":"Inputs","text":"Name Data Type Description message <code>list[ContentItem] or str</code>"},{"location":"block-reference/LLM/#outputs","title":"Outputs","text":"Name Data Type Description response <code>ResponseSchemaT</code>"},{"location":"block-reference/LLM/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/LLM/#examples","title":"Example(s)","text":""},{"location":"block-reference/LLM/#example-1-generate-a-simple-response-from-the-llm","title":"Example 1: Generate a simple response from the LLM","text":"<ul> <li>Create an <code>LLM</code> Block.</li> <li>Set the <code>llm_config</code> with the model details and pre-prompt.</li> <li>Provide an input message: <code>\"Summarize this document.\"</code></li> <li>The Block will use the LLM to generate a text response and send it to the <code>response</code> output.</li> </ul>"},{"location":"block-reference/LLM/#example-2-use-a-custom-response-schema","title":"Example 2: Use a custom response schema","text":"<ul> <li>Set up an <code>LLM</code> Block.</li> <li>Define a custom <code>response_schema</code> that expects an object with specific fields, such as <code>{\"type\": \"object\", \"properties\": {\"summary\": {\"type\": \"string\"}}}</code>.</li> <li>Provide the input message: <code>\"Summarize the following content.\"</code></li> <li>The Block will output the structured response, matching the defined schema.</li> </ul>"},{"location":"block-reference/LLM/#example-3-use-thread-history-for-context","title":"Example 3: Use thread history for context","text":"<ul> <li>Create an <code>LLM</code> Block with <code>use_thread_history</code> set to <code>True</code>.</li> <li>Provide a series of messages over multiple steps.</li> <li>The Block will use the entire conversation history to generate contextually aware responses.</li> </ul>"},{"location":"block-reference/LLM/#error-handling","title":"Error Handling","text":"<ul> <li>If the LLM response does not match the expected schema, the Block will attempt to map the response to the <code>response_schema</code>.</li> <li>If the schema is not an object and the response is not a string, the Block will raise an error during validation.</li> </ul>"},{"location":"block-reference/LLM/#faq","title":"FAQ","text":"What happens if the response schema is not provided? <p>If no <code>response_schema</code> is provided, the Block assumes the response is a simple string and processes it accordingly.</p> How does the Block handle structured responses? <p>If a structured <code>response_schema</code> is defined, the Block expects the LLM to return data that matches the schema. The response is then parsed and sent to the <code>response</code> output.</p> Can I use the Block without thread history? <p>Yes, by setting <code>use_thread_history</code> to <code>False</code>, the Block will only use the current message in its response generation, without considering previous interactions.</p> What happens if the LLM response type is a tool call? <p>If the LLM response is a tool call, the Block will process the tool call arguments and return the result based on the provided schema.</p>"},{"location":"block-reference/LLMSelect/","title":"LLMSelect","text":""},{"location":"block-reference/LLMSelect/#overview","title":"Overview","text":"<p>The <code>LLMSelect</code> Block is designed to interact with a Language Learning Model (LLM) and present a list of options based on a user\u2019s input. The LLM evaluates the input message and selects one of the predefined options based on the description of each option. This Block is useful for scenarios where the LLM needs to make decisions between different possible actions or tools.</p>"},{"location":"block-reference/LLMSelect/#description","title":"Description","text":""},{"location":"block-reference/LLMSelect/#metadata","title":"Metadata","text":"<ul> <li>Category: Agent</li> </ul>"},{"location":"block-reference/LLMSelect/#configuration-options","title":"Configuration Options","text":"Name Data Type Description Default Value use_thread_history <code>bool</code>"},{"location":"block-reference/LLMSelect/#inputs","title":"Inputs","text":"Name Data Type Description message <code>list[ContentItem] or str</code>"},{"location":"block-reference/LLMSelect/#outputs","title":"Outputs","text":"<p>No outputs available.</p>"},{"location":"block-reference/LLMSelect/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/LLMSelect/#examples","title":"Example(s)","text":""},{"location":"block-reference/LLMSelect/#example-1-use-llm-to-select-an-option","title":"Example 1: Use LLM to select an option","text":"<ul> <li>Create an <code>LLMSelect</code> Block.</li> <li>Define options such as <code>\"Option1: Perform Action A\"</code> and <code>\"Option2: Perform Action B\"</code>.</li> <li>Provide an input message: <code>\"Which action should I take?\"</code>.</li> <li>The Block will use the LLM to analyze the message and select the appropriate option based on the provided descriptions.</li> </ul>"},{"location":"block-reference/LLMSelect/#example-2-use-thread-history-in-decision-making","title":"Example 2: Use thread history in decision-making","text":"<ul> <li>Set up an <code>LLMSelect</code> Block with <code>use_thread_history</code> set to <code>True</code>.</li> <li>Provide a series of messages or a conversation history.</li> <li>The Block will use the entire thread history when making the decision, ensuring that the context of the conversation is maintained.</li> </ul>"},{"location":"block-reference/LLMSelect/#error-handling","title":"Error Handling","text":"<ul> <li>If the LLM settings are unexpectedly <code>None</code>, an exception will be raised.</li> <li>If the LLM response does not match any of the predefined options, the Block will raise an exception.</li> </ul>"},{"location":"block-reference/LLMSelect/#faq","title":"FAQ","text":"What happens if the LLM cannot choose an option? <p>If the LLM's response does not match any of the available options, the Block will raise an exception. Ensure that the option descriptions are clear and distinguishable.</p> Can I use the LLMSelect Block with multiple options? <p>Yes, you can define multiple options in the <code>options</code> dictionary. Each option has a description that helps guide the LLM in making its selection.</p> How does the Block use thread history? <p>If <code>use_thread_history</code> is set to <code>True</code>, the Block will include previous messages in the conversation as part of the LLM's decision-making process. This helps maintain context when selecting an option.</p> What happens if the LLM response is ambiguous? <p>The Block checks the LLM's response against the available options in descending order of length to find a match. If the response does not match any option, an exception is raised.</p>"},{"location":"block-reference/LLMWithTools/","title":"LLMWithTools","text":""},{"location":"block-reference/LLMWithTools/#overview","title":"Overview","text":"<p>The <code>LLMWithTools</code> Block allows interaction with a Language Learning Model (LLM) and integrates additional tools to assist the LLM in generating more complex responses. This Block supports multiple tools, which can be invoked by the LLM when needed. It manages both the LLM's responses and the results from tool invocations.</p> <p>This Block is useful when you want the LLM to dynamically call different tools based on user inputs, allowing for more versatile and context-aware conversations.</p>"},{"location":"block-reference/LLMWithTools/#description","title":"Description","text":""},{"location":"block-reference/LLMWithTools/#metadata","title":"Metadata","text":"<ul> <li>Category: Agent</li> </ul>"},{"location":"block-reference/LLMWithTools/#configuration-options","title":"Configuration Options","text":"Name Data Type Description Default Value use_thread_history <code>bool</code>"},{"location":"block-reference/LLMWithTools/#inputs","title":"Inputs","text":"Name Data Type Description message <code>list[ContentItem] or str</code>"},{"location":"block-reference/LLMWithTools/#outputs","title":"Outputs","text":"Name Data Type Description response <code>ResponseSchemaT</code>"},{"location":"block-reference/LLMWithTools/#state-variables","title":"State Variables","text":"Name Data Type Description message <code>list[ContentItem] or str</code> tool_calls <code>dict[(str, dict[(str, Any)])]</code> tool_messages <code>list[AssistantMessage or ToolMessage]</code>"},{"location":"block-reference/LLMWithTools/#examples","title":"Example(s)","text":""},{"location":"block-reference/LLMWithTools/#example-1-use-the-llm-to-select-a-tool","title":"Example 1: Use the LLM to select a tool","text":"<ul> <li>Create an <code>LLMWithTools</code> Block.</li> <li>Define tools like <code>\"Tool1\"</code> and <code>\"Tool2\"</code> that the LLM can choose from.</li> <li>Provide an input message: <code>\"Which tool should I use for this task?\"</code></li> <li>The Block will invoke the appropriate tool based on the LLM\u2019s decision, process the result, and return a response.</li> </ul>"},{"location":"block-reference/LLMWithTools/#example-2-handling-a-response-without-tool-invocation","title":"Example 2: Handling a response without tool invocation","text":"<ul> <li>Set up an <code>LLMWithTools</code> Block with tools defined.</li> <li>Provide a message where no tool invocation is necessary: <code>\"Summarize the document.\"</code></li> <li>The LLM will generate the response directly and send it back without calling any tools.</li> </ul>"},{"location":"block-reference/LLMWithTools/#example-3-multiple-tool-calls-in-a-single-interaction","title":"Example 3: Multiple tool calls in a single interaction","text":"<ul> <li>Set up an <code>LLMWithTools</code> Block.</li> <li>The LLM can call multiple tools during the interaction, processing each tool\u2019s output and using the results to generate a final response.</li> </ul>"},{"location":"block-reference/LLMWithTools/#error-handling","title":"Error Handling","text":"<ul> <li>If tool results are not available, the Block will raise an error.</li> <li>If the LLM response type is unexpected, the Block will attempt to handle the error gracefully by sending back a default response.</li> </ul>"},{"location":"block-reference/LLMWithTools/#faq","title":"FAQ","text":"How does the Block handle tool invocations? <p>The LLM can call tools defined in the <code>tools</code> dictionary. The Block waits for the tool's results, appends the result to the conversation history, and allows the LLM to continue processing the message.</p> Can I define custom tools for the LLM to use? <p>Yes, you can define custom tools in the <code>tools</code> dictionary. Each tool has its own functionality and can be invoked by the LLM during conversation based on the input message.</p> What happens if the LLM doesn\u2019t need a tool? <p>If the LLM determines that no tools are necessary for a particular response, it will generate the response directly and return it without invoking any tools.</p> Can the Block handle multiple tool calls in a single interaction? <p>Yes, the Block is capable of handling multiple tool calls in a single interaction. It manages tool call results and appends them to the conversation history, ensuring that the LLM can utilize multiple tools as needed.</p>"},{"location":"block-reference/Map/","title":"Map","text":""},{"location":"block-reference/Map/#overview","title":"Overview","text":"<p>The <code>Map</code> Block is designed to iterate through a list of items and process each item using a configured tool. The results from processing each item are collected and outputted as a list once all items have been processed.</p> <p>The Block works generically with any input type (<code>ItemT</code>) and any result type (<code>ResultT</code>), making it versatile for various use cases where a list of items needs to be transformed or processed individually.</p>"},{"location":"block-reference/Map/#description","title":"Description","text":"<p>Loops through each item in the items input and sends them to the configured tool. Once all items have been processed, outputs the resulting list</p>"},{"location":"block-reference/Map/#metadata","title":"Metadata","text":"<ul> <li>Category: Function</li> </ul>"},{"location":"block-reference/Map/#configuration-options","title":"Configuration Options","text":"<p>No configuration options available.</p>"},{"location":"block-reference/Map/#inputs","title":"Inputs","text":"Name Data Type Description items <code>list[ItemT]</code>"},{"location":"block-reference/Map/#outputs","title":"Outputs","text":"Name Data Type Description results <code>list[ResultT]</code>"},{"location":"block-reference/Map/#state-variables","title":"State Variables","text":"Name Data Type Description count <code>int</code> results_state <code>list[Any]</code>"},{"location":"block-reference/Map/#examples","title":"Example(s)","text":""},{"location":"block-reference/Map/#example-1-process-a-list-of-numbers","title":"Example 1: Process a list of numbers","text":"<ul> <li>Create a <code>Map</code> Block.</li> <li>Configure the <code>run</code> operation to multiply each number by 2.</li> <li>Provide the input list: <code>[1, 2, 3, 4]</code>.</li> <li>The <code>Map</code> Block will process each number, applying the multiplication, and output <code>[2, 4, 6, 8]</code>.</li> </ul>"},{"location":"block-reference/Map/#example-2-map-over-a-list-of-strings","title":"Example 2: Map over a list of strings","text":"<ul> <li>Set up a <code>Map</code> Block.</li> <li>Configure the <code>run</code> operation to append \"processed\" to each string.</li> <li>Provide the input list: <code>[\"item1\", \"item2\"]</code>.</li> <li>The output will be <code>[\"item1 processed\", \"item2 processed\"]</code> after processing.</li> </ul>"},{"location":"block-reference/Map/#example-3-use-with-an-async-operation","title":"Example 3: Use with an async operation","text":"<ul> <li>Create a <code>Map</code> Block that performs an asynchronous operation, such as fetching data from an API.</li> <li>Provide a list of IDs as the input: <code>[123, 456, 789]</code>.</li> <li>The <code>Map</code> Block will process each ID, fetch data from the API, and return the results as a list.</li> </ul>"},{"location":"block-reference/Map/#error-handling","title":"Error Handling","text":"<ul> <li>If the input list is empty, the <code>Map</code> Block will return an empty list without processing any items.</li> <li>The <code>Map</code> Block tracks the processing of each item. If there is an issue while processing a specific item (e.g., a failure in the <code>run</code> operation), the result for that item may remain unprocessed unless handled.</li> <li>Ensure that the <code>run</code> operation is configured correctly to avoid errors during processing.</li> </ul>"},{"location":"block-reference/Map/#faq","title":"FAQ","text":"What happens if an error occurs during the <code>run</code> operation? <p>If an error occurs during the <code>run</code> operation, the <code>Map</code> Block will not stop the entire process. Instead, it will continue processing the remaining items in the list. You may need to handle errors in the <code>run</code> operation to ensure robust behavior.</p> Can I use this block to process items asynchronously? <p>Yes, the <code>Map</code> Block supports asynchronous operations. The <code>run</code> operation can be configured to perform async tasks, and the Block will await the results before continuing to the next item.</p> How can I track the progress of the mapping operation? <p>The Block provides an internal <code>count</code> state that tracks how many items remain to be processed. You can use this state to monitor the progress of the operation.</p>"},{"location":"block-reference/MergeLists/","title":"MergeLists","text":""},{"location":"block-reference/MergeLists/#overview","title":"Overview","text":"<p>The <code>MergeLists</code> Block merges two lists of objects (dictionaries) based on a matching key. It takes two input lists and combines the dictionaries from both lists where the specified key is equal. If both lists contain objects with the same key, their values are merged, with values from the second list overriding those from the first in case of conflicts.</p> <p>This Block is useful for combining datasets or lists where you need to merge records with the same identifier.</p>"},{"location":"block-reference/MergeLists/#description","title":"Description","text":"<p>Merges objects from two lists by matching on the configured key</p>"},{"location":"block-reference/MergeLists/#metadata","title":"Metadata","text":"<ul> <li>Category: Function</li> </ul>"},{"location":"block-reference/MergeLists/#configuration-options","title":"Configuration Options","text":"Name Data Type Description Default Value key <code>str</code>"},{"location":"block-reference/MergeLists/#inputs","title":"Inputs","text":"Name Data Type Description a <code>list[dict[(str, Any)]]</code> b <code>list[dict[(str, Any)]]</code>"},{"location":"block-reference/MergeLists/#outputs","title":"Outputs","text":"Name Data Type Description result <code>list[dict[(str, Any)]]</code>"},{"location":"block-reference/MergeLists/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/MergeLists/#examples","title":"Example(s)","text":""},{"location":"block-reference/MergeLists/#example-1-merge-two-lists-of-dictionaries","title":"Example 1: Merge two lists of dictionaries","text":"<ul> <li>Create a <code>MergeLists</code> Block.</li> <li>Set the <code>key</code> to <code>\"id\"</code>.</li> <li>Provide the input lists:</li> <li><code>a = [{\"id\": 1, \"name\": \"John\"}, {\"id\": 2, \"name\": \"Jane\"}]</code></li> <li><code>b = [{\"id\": 1, \"age\": 30}, {\"id\": 3, \"name\": \"Jim\"}]</code></li> <li>The Block will output:   <pre><code>[\n  {\"id\": 1, \"name\": \"John\", \"age\": 30},\n  {\"id\": 2, \"name\": \"Jane\"},\n  {\"id\": 3, \"name\": \"Jim\"}\n]\n</code></pre></li> </ul>"},{"location":"block-reference/MergeLists/#example-2-handle-missing-keys-in-one-list","title":"Example 2: Handle missing keys in one list","text":"<ul> <li>Set up a <code>MergeLists</code> Block.</li> <li>Set the <code>key</code> to <code>\"code\"</code>.</li> <li>Provide the input lists:</li> <li><code>a = [{\"code\": \"A\", \"value\": 100}, {\"code\": \"B\", \"value\": 200}]</code></li> <li><code>b = [{\"code\": \"A\", \"description\": \"First\"}, {\"code\": \"C\", \"value\": 300}]</code></li> <li>The Block will output:   <pre><code>[\n  {\"code\": \"A\", \"value\": 100, \"description\": \"First\"},\n  {\"code\": \"B\", \"value\": 200},\n  {\"code\": \"C\", \"value\": 300}\n]\n</code></pre></li> </ul>"},{"location":"block-reference/MergeLists/#example-3-merge-lists-with-no-overlapping-keys","title":"Example 3: Merge lists with no overlapping keys","text":"<ul> <li>Create a <code>MergeLists</code> Block.</li> <li>Set the <code>key</code> to <code>\"id\"</code>.</li> <li>Provide two lists with no overlapping keys:</li> <li><code>a = [{\"id\": 1, \"data\": \"X\"}]</code></li> <li><code>b = [{\"id\": 2, \"data\": \"Y\"}]</code></li> <li>The Block will output:   <pre><code>[\n  {\"id\": 1, \"data\": \"X\"},\n  {\"id\": 2, \"data\": \"Y\"}\n]\n</code></pre></li> </ul>"},{"location":"block-reference/MergeLists/#error-handling","title":"Error Handling","text":"<ul> <li>If any object in the input lists does not contain the specified key, the Block will raise a <code>KeyError</code>. Ensure that all objects in both lists contain the key specified in the <code>key</code> configuration.</li> <li>The Block assumes that the values of the key field are unique within each list. If there are duplicate keys within a list, the Block will only consider the last occurrence of each key.</li> </ul>"},{"location":"block-reference/MergeLists/#faq","title":"FAQ","text":"What happens if one list has objects with keys that don't exist in the other list? <p>The Block will still include those objects in the final result. Objects that only exist in one list will be added as-is without merging.</p> What if the two lists have different fields for the same key? <p>If both lists contain objects with the same key but different fields, the resulting merged object will include fields from both lists. In case of conflicting fields, the values from the second list will override the values from the first list.</p> Can I merge more than two lists using this Block? <p>The <code>MergeLists</code> Block only supports merging two lists at a time. To merge more than two lists, you can chain multiple <code>MergeLists</code> Blocks or merge the lists step by step.</p> What if a list contains duplicate keys? <p>If either list contains duplicate keys, only the last occurrence of each key will be considered. The Block does not handle merging objects with duplicate keys within a single list.</p>"},{"location":"block-reference/ParseJson/","title":"ParseJson","text":""},{"location":"block-reference/ParseJson/#overview","title":"Overview","text":"<p>The <code>ParseJson</code> Block parses a JSON string or a list of JSON strings into Python dictionaries. This Block accepts either a single JSON string or a list of JSON strings and converts them into their corresponding dictionary or list of dictionaries, respectively. It is useful when you need to work with structured JSON data in subsequent steps.</p>"},{"location":"block-reference/ParseJson/#description","title":"Description","text":"<p>This block takes a JSON string or a list of JSON strings and parses them</p>"},{"location":"block-reference/ParseJson/#metadata","title":"Metadata","text":"<ul> <li>Category: Function</li> </ul>"},{"location":"block-reference/ParseJson/#configuration-options","title":"Configuration Options","text":"<p>No configuration options available.</p>"},{"location":"block-reference/ParseJson/#inputs","title":"Inputs","text":"Name Data Type Description json_string <code>Union[(str, List[str])]</code> JSON string or list of JSON strings"},{"location":"block-reference/ParseJson/#outputs","title":"Outputs","text":"Name Data Type Description json <code>dict[(str, Any)] or list[dict[(str, Any)]]</code>"},{"location":"block-reference/ParseJson/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/ParseJson/#examples","title":"Example(s)","text":""},{"location":"block-reference/ParseJson/#example-1-parse-a-single-json-string","title":"Example 1: Parse a single JSON string","text":"<ul> <li>Create a <code>ParseJson</code> Block.</li> <li>Provide the input: <code>'{\"name\": \"John\", \"age\": 30}'</code>.</li> <li>The Block will parse the JSON string and output: <code>{\"name\": \"John\", \"age\": 30}</code> as a dictionary.</li> </ul>"},{"location":"block-reference/ParseJson/#example-2-parse-a-list-of-json-strings","title":"Example 2: Parse a list of JSON strings","text":"<ul> <li>Set up a <code>ParseJson</code> Block.</li> <li>Provide a list of JSON strings: <code>['{\"name\": \"John\"}', '{\"name\": \"Jane\"}']</code>.</li> <li>The Block will output: <code>[{\"name\": \"John\"}, {\"name\": \"Jane\"}]</code>, a list of dictionaries.</li> </ul>"},{"location":"block-reference/ParseJson/#example-3-handle-invalid-json","title":"Example 3: Handle invalid JSON","text":"<ul> <li>Create a <code>ParseJson</code> Block.</li> <li>Provide an invalid JSON string: <code>'{\"name\": \"John\"'</code>.</li> <li>The Block will raise a <code>JSONDecodeError</code> due to the invalid JSON format.</li> </ul>"},{"location":"block-reference/ParseJson/#error-handling","title":"Error Handling","text":"<ul> <li>If the input is not a valid JSON string, the Block will raise a <code>JSONDecodeError</code>.</li> <li>If a list of JSON strings is provided and any of them are invalid, the Block will raise an error indicating which string caused the issue.</li> <li>If the input is neither a string nor a list of strings, the Block will raise an error.</li> </ul>"},{"location":"block-reference/ParseJson/#faq","title":"FAQ","text":"What happens if I provide an invalid JSON string? <p>If you provide an invalid JSON string, the <code>ParseJson</code> Block will raise a <code>JSONDecodeError</code>. Make sure that the JSON string is well-formed and valid before passing it to the Block.</p> Can I pass both single and multiple JSON strings? <p>Yes, the <code>ParseJson</code> Block accepts both a single JSON string and a list of JSON strings. It will parse each string individually and return the appropriate Python dictionary or list of dictionaries.</p> What happens if I pass an empty string? <p>If an empty string is provided, the <code>ParseJson</code> Block will raise a <code>JSONDecodeError</code>, as an empty string is not valid JSON.</p> Does this Block handle complex JSON structures? <p>Yes, the <code>ParseJson</code> Block can handle complex JSON structures, including nested objects and arrays. It will parse them into corresponding Python dictionaries and lists.</p>"},{"location":"block-reference/RegexMatch/","title":"RegexMatch","text":""},{"location":"block-reference/RegexMatch/#overview","title":"Overview","text":"<p>The <code>RegexMatch</code> Block performs regex-based pattern matching on a string input. It applies the provided regex expression to the input string and returns a list of all matches found. If no matches are found, the Block returns <code>[\"No match found\"]</code>.</p> <p>This Block is useful for extracting data based on specific patterns in strings, such as emails, phone numbers, or other formats.</p>"},{"location":"block-reference/RegexMatch/#description","title":"Description","text":"<p>regex-based pattern matching on a string input, returning a list of all matches found.</p>"},{"location":"block-reference/RegexMatch/#metadata","title":"Metadata","text":"<ul> <li>Category: Function</li> </ul>"},{"location":"block-reference/RegexMatch/#configuration-options","title":"Configuration Options","text":"Name Data Type Description Default Value regex <code>str</code> <code>.*</code>"},{"location":"block-reference/RegexMatch/#inputs","title":"Inputs","text":"Name Data Type Description input_strings <code>str</code>"},{"location":"block-reference/RegexMatch/#outputs","title":"Outputs","text":"Name Data Type Description result <code>list[str]</code>"},{"location":"block-reference/RegexMatch/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/RegexMatch/#examples","title":"Example(s)","text":""},{"location":"block-reference/RegexMatch/#example-1-find-all-numbers-in-a-string","title":"Example 1: Find all numbers in a string","text":"<ul> <li>Create a <code>RegexMatch</code> Block.</li> <li>Set the <code>regex</code> to <code>\\d+</code> (this regex matches one or more digits).</li> <li>Provide the input string: <code>\"My phone number is 12345 and my zip code is 67890.\"</code></li> <li>The Block will output: <code>[\"12345\", \"67890\"]</code>.</li> </ul>"},{"location":"block-reference/RegexMatch/#example-2-match-words-starting-with-a-specific-letter","title":"Example 2: Match words starting with a specific letter","text":"<ul> <li>Set up a <code>RegexMatch</code> Block.</li> <li>Set the <code>regex</code> to <code>\\b[Aa]\\w*</code> (this regex matches words starting with \"A\" or \"a\").</li> <li>Provide the input string: <code>\"Alice and Bob are attending the event.\"</code></li> <li>The Block will output: <code>[\"Alice\", \"and\", \"are\"]</code>.</li> </ul>"},{"location":"block-reference/RegexMatch/#example-3-no-matches-found","title":"Example 3: No matches found","text":"<ul> <li>Create a <code>RegexMatch</code> Block.</li> <li>Set the <code>regex</code> to <code>\\d+</code> (this regex matches digits).</li> <li>Provide the input string: <code>\"No numbers here.\"</code></li> <li>The Block will output: <code>[\"No match found\"]</code> as there are no digits in the string.</li> </ul>"},{"location":"block-reference/RegexMatch/#example-4-handle-regex-errors","title":"Example 4: Handle regex errors","text":"<ul> <li>Create a <code>RegexMatch</code> Block.</li> <li>Set an invalid regex, such as <code>\\d++</code>.</li> <li>The Block will return an error message like <code>[\"Error: nothing to repeat at position 3\"]</code>.</li> </ul>"},{"location":"block-reference/RegexMatch/#error-handling","title":"Error Handling","text":"<ul> <li>If the regex pattern is invalid, the Block will return a list containing an error message with the exception details.</li> <li>If no matches are found, the Block will return <code>[\"No match found\"]</code>.</li> </ul>"},{"location":"block-reference/RegexMatch/#faq","title":"FAQ","text":"What happens if the regex pattern is invalid? <p>If the provided regex pattern is invalid, the Block will catch the exception and return a list containing the error message. This allows you to handle regex-related errors gracefully.</p> Can I use this Block for complex regex patterns? <p>Yes, the <code>RegexMatch</code> Block supports any valid regex pattern, allowing you to handle complex string matching tasks such as extracting specific formats or patterns from text.</p> What if the input string contains no matches? <p>If the input string does not match the provided regex pattern, the Block will return <code>[\"No match found\"]</code>.</p> Does this Block support multiline input? <p>Yes, the Block can handle multiline input, but you'll need to adjust the regex pattern accordingly (e.g., use <code>re.MULTILINE</code> or include newline characters in the regex if needed).</p>"},{"location":"block-reference/SemanticChunk/","title":"SemanticChunk","text":""},{"location":"block-reference/SemanticChunk/#overview","title":"Overview","text":"<p>The <code>SemanticChunk</code> Block is used to split a document into semantic chunks, with each chunk being a group of semantically related sentences. The Block utilizes an embedding model to evaluate the semantic similarity between sentences and decides when to form a new chunk based on a configurable dissimilarity threshold.</p> <p>This Block is useful for breaking down large documents into smaller, meaningful sections for tasks like summarization, topic modeling, or information extraction.</p>"},{"location":"block-reference/SemanticChunk/#description","title":"Description","text":"<p>Semantic chunk parser.</p> <p>Splits a document into Chunks, with each node being a group of semantically related sentences.</p> <p>Args: buffer_size (int): number of sentences to group together when evaluating semantic similarity chunk_model: (BaseEmbedding): embedding model to use, defaults to BAAI/bge-small-en-v1.5 breakpoint_percentile_threshold: (int): the percentile of cosine dissimilarity that must be exceeded between a group of sentences and the next to form a node. The smaller this number is, the more nodes will be generated</p>"},{"location":"block-reference/SemanticChunk/#metadata","title":"Metadata","text":"<ul> <li>Category: Function</li> </ul>"},{"location":"block-reference/SemanticChunk/#configuration-options","title":"Configuration Options","text":"Name Data Type Description Default Value buffer_size <code>int</code> <code>1</code> breakpoint_percentile_threshold <code>int</code> <code>95</code> model_name <code>str</code> <code>BAAI/bge-small-en-v1.5</code>"},{"location":"block-reference/SemanticChunk/#inputs","title":"Inputs","text":"Name Data Type Description text <code>str or list[str]</code>"},{"location":"block-reference/SemanticChunk/#outputs","title":"Outputs","text":"Name Data Type Description result <code>list[str]</code>"},{"location":"block-reference/SemanticChunk/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/SemanticChunk/#examples","title":"Example(s)","text":""},{"location":"block-reference/SemanticChunk/#example-1-split-a-document-into-chunks","title":"Example 1: Split a document into chunks","text":"<ul> <li>Create a <code>SemanticChunk</code> Block.</li> <li>Set the <code>buffer_size</code> to <code>2</code> (group sentences in batches of 2).</li> <li>Set the <code>breakpoint_percentile_threshold</code> to <code>90</code>.</li> <li>Provide the input text: <code>\"The quick brown fox jumps over the lazy dog. This is a test sentence. Semantic chunking is a powerful tool.\"</code></li> <li>The Block will output a list of chunks, such as:   <pre><code>[\n  \"The quick brown fox jumps over the lazy dog. This is a test sentence.\",\n  \"Semantic chunking is a powerful tool.\"\n]\n</code></pre></li> </ul>"},{"location":"block-reference/SemanticChunk/#example-2-handle-a-list-of-documents","title":"Example 2: Handle a list of documents","text":"<ul> <li>Set up a <code>SemanticChunk</code> Block.</li> <li>Provide a list of text documents:   <pre><code>[\n  \"Document 1: The sky is blue.\",\n  \"Document 2: The sun is bright.\"\n]\n</code></pre></li> <li>The Block will split each document into semantic chunks and return the result:   <pre><code>[\n  \"Document 1: The sky is blue.\",\n  \"Document 2: The sun is bright.\"\n]\n</code></pre></li> </ul>"},{"location":"block-reference/SemanticChunk/#example-3-use-a-custom-embedding-model","title":"Example 3: Use a custom embedding model","text":"<ul> <li>Set the <code>model_name</code> to <code>\"custom/embedding-model\"</code> to use a specific embedding model for chunking.</li> <li>Provide the text to be chunked: <code>\"This is a test for using a custom model.\"</code></li> <li>The Block will use the custom model for embedding and chunking the text.</li> </ul>"},{"location":"block-reference/SemanticChunk/#error-handling","title":"Error Handling","text":"<ul> <li>If the input text is invalid or there is an error during the chunking process, the Block will raise a <code>RuntimeError</code> with a descriptive error message.</li> <li>If no chunks are generated, the Block will return a list containing an empty string.</li> </ul>"},{"location":"block-reference/SemanticChunk/#faq","title":"FAQ","text":"What does the <code>buffer_size</code> parameter do? <p>The <code>buffer_size</code> parameter determines the number of sentences that are grouped together when evaluating semantic similarity. A higher buffer size will result in larger chunks, while a smaller buffer size will create more granular chunks.</p> What is the <code>breakpoint_percentile_threshold</code>? <p>The <code>breakpoint_percentile_threshold</code> is the percentile of cosine dissimilarity that must be exceeded between a group of sentences and the next to form a new chunk. A lower threshold will create more chunks, while a higher threshold will create fewer, larger chunks.</p> Can I use a custom embedding model for semantic chunking? <p>Yes, you can specify a custom embedding model by setting the <code>model_name</code> parameter to the name of the model you want to use. The default model is <code>\"BAAI/bge-small-en-v1.5\"</code>.</p> What happens if no semantic chunks are created? <p>If no semantic chunks are created, the Block will return a list containing an empty string to indicate that no meaningful chunks were found.</p>"},{"location":"block-reference/SentenceChunk/","title":"SentenceChunk","text":""},{"location":"block-reference/SentenceChunk/#overview","title":"Overview","text":"<p>The <code>SentenceChunk</code> Block parses text with a preference for keeping complete sentences and paragraphs together. This Block aims to create chunks of text that maintain sentence integrity, making it useful for tasks where meaningful text divisions are important, such as summarization or token-limited models.</p> <p>The Block uses a combination of sentence splitting, token counting, and customizable chunk sizes and overlaps. It also supports a secondary chunking regex for additional control over sentence splitting.</p>"},{"location":"block-reference/SentenceChunk/#description","title":"Description","text":"<p>Parse text with a preference for complete sentences.</p> <p>In general, this class tries to keep sentences and paragraphs together. Therefore compared to the original TokenTextSplitter, there are less likely to be hanging sentences or parts of sentences at the end of the node chunk.</p> <p>Args: chunk_size: The number of tokens to include in each chunk. (default is 200) chunk_overlap: The number of tokens that overlap between consecutive chunks. (default is 10) separator: Default separator for splitting into words. (default is \" \") paragraph_separator: Separator between paragraphs. (default is \"\\n\\n\\n\") secondary_chunking_regex: Backup regex for splitting into sentences.(default is \"[^,.;]+[,.;]?\".)</p> <p>Steps: 1: Break text into splits that are smaller than chunk size base on the separators and regex. 2: Combine splits into chunks of size chunk_size (smaller than).</p>"},{"location":"block-reference/SentenceChunk/#metadata","title":"Metadata","text":"<ul> <li>Category: Function</li> </ul>"},{"location":"block-reference/SentenceChunk/#configuration-options","title":"Configuration Options","text":"Name Data Type Description Default Value chunk_size <code>int</code> <code>200</code> chunk_overlap <code>int</code> <code>10</code> separator <code>str</code> <code></code> paragraph_separator <code>str</code> <code>\\n\\n\\n</code> model_name <code>str</code> <code>gpt-3.5-turbo</code> secondary_chunking_regex <code>str</code> <code>[^,.;\u3002\uff1f\uff01]+[,.;\u3002\uff1f\uff01]?</code>"},{"location":"block-reference/SentenceChunk/#inputs","title":"Inputs","text":"Name Data Type Description text <code>str or list[str]</code>"},{"location":"block-reference/SentenceChunk/#outputs","title":"Outputs","text":"Name Data Type Description result <code>list[str]</code>"},{"location":"block-reference/SentenceChunk/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/SentenceChunk/#examples","title":"Example(s)","text":""},{"location":"block-reference/SentenceChunk/#example-1-chunk-a-document-with-default-settings","title":"Example 1: Chunk a document with default settings","text":"<ul> <li>Create a <code>SentenceChunk</code> Block.</li> <li>Set the <code>chunk_size</code> to <code>200</code> tokens and <code>chunk_overlap</code> to <code>10</code>.</li> <li>Provide the input text: <code>\"This is the first sentence. This is the second sentence. This is the third sentence.\"</code></li> <li>The Block will output chunks, keeping sentences together while staying within the token limit, such as:   <pre><code>[\n  \"This is the first sentence. This is the second sentence.\",\n  \"This is the second sentence. This is the third sentence.\"\n]\n</code></pre></li> </ul>"},{"location":"block-reference/SentenceChunk/#example-2-use-a-custom-paragraph-separator","title":"Example 2: Use a custom paragraph separator","text":"<ul> <li>Set up a <code>SentenceChunk</code> Block.</li> <li>Set the <code>paragraph_separator</code> to <code>\"\\n\\n\"</code>.</li> <li>Provide a text input with paragraphs separated by double newlines:   <pre><code>\"Paragraph one text.\\n\\nParagraph two text.\"\n</code></pre></li> <li>The Block will chunk the paragraphs based on the provided separator.</li> </ul>"},{"location":"block-reference/SentenceChunk/#example-3-handle-complex-sentence-structures-with-custom-regex","title":"Example 3: Handle complex sentence structures with custom regex","text":"<ul> <li>Create a <code>SentenceChunk</code> Block.</li> <li>Set the <code>secondary_chunking_regex</code> to <code>\"[.!?]+\"</code> to split based on sentence-ending punctuation.</li> <li>Provide the input: <code>\"Complex sentences can have multiple clauses; splitting them requires attention to detail.\"</code></li> <li>The Block will split the text at appropriate points while maintaining sentence integrity.</li> </ul>"},{"location":"block-reference/SentenceChunk/#error-handling","title":"Error Handling","text":"<ul> <li>If the tokenizer cannot be loaded for the specified model, the Block will raise a <code>RuntimeError</code> with an appropriate error message.</li> <li>If an issue occurs during chunking, the Block will raise a <code>RuntimeError</code> describing the problem.</li> </ul>"},{"location":"block-reference/SentenceChunk/#faq","title":"FAQ","text":"What does the <code>chunk_size</code> parameter do? <p>The <code>chunk_size</code> parameter controls the number of tokens that each chunk should contain. The Block attempts to keep chunks within this size while preserving complete sentences and paragraphs.</p> What is the <code>chunk_overlap</code> parameter? <p>The <code>chunk_overlap</code> parameter specifies the number of tokens that should overlap between consecutive chunks. This ensures that no important information is lost at chunk boundaries.</p> Can I customize the separators used for splitting text? <p>Yes, you can customize both the <code>separator</code> for splitting words and the <code>paragraph_separator</code> for splitting paragraphs. By default, the word separator is a space (<code>\" \"</code>), and the paragraph separator is <code>\"\\n\\n\\n\"</code>.</p> What happens if no valid chunks are created? <p>If no valid chunks are created, the Block will return a list containing an empty string to indicate that no meaningful chunks were generated from the input text.</p> Can I use a custom model for tokenization? <p>Yes, you can specify a custom model for tokenization by setting the <code>model_name</code> parameter. The Block will use the specified model's tokenizer to encode the text into tokens.</p>"},{"location":"block-reference/Slice/","title":"Slice","text":""},{"location":"block-reference/Slice/#overview","title":"Overview","text":"<p>The <code>Slice</code> Block is used to extract a portion of a list or string based on configured start and end indexes. The Block slices the input according to these indexes and outputs the sliced result. It can handle both lists and strings, making it versatile for various slicing operations.</p> <p>By default, the start index is set to <code>0</code>, and the end index is set to <code>0</code>, which means no slicing will occur unless the indexes are adjusted.</p>"},{"location":"block-reference/Slice/#description","title":"Description","text":"<p>Slices a list or string using the configured start and end indexes</p>"},{"location":"block-reference/Slice/#metadata","title":"Metadata","text":"<ul> <li>Category: Function</li> </ul>"},{"location":"block-reference/Slice/#configuration-options","title":"Configuration Options","text":"Name Data Type Description Default Value start <code>int</code> <code>0</code> end <code>int</code> <code>0</code>"},{"location":"block-reference/Slice/#inputs","title":"Inputs","text":"Name Data Type Description items <code>list[Any] or str</code>"},{"location":"block-reference/Slice/#outputs","title":"Outputs","text":"Name Data Type Description items <code>list[Any] or str</code>"},{"location":"block-reference/Slice/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/Slice/#examples","title":"Example(s)","text":""},{"location":"block-reference/Slice/#example-1-slice-a-list-of-numbers","title":"Example 1: Slice a list of numbers","text":"<ul> <li>Create a <code>Slice</code> Block.</li> <li>Set the <code>start</code> index to <code>1</code> and the <code>end</code> index to <code>3</code>.</li> <li>Provide the input list: <code>[10, 20, 30, 40]</code>.</li> <li>The Block will output <code>[20, 30]</code> (elements from index <code>1</code> to <code>3</code>, not including <code>3</code>).</li> </ul>"},{"location":"block-reference/Slice/#example-2-slice-a-string","title":"Example 2: Slice a string","text":"<ul> <li>Set up a <code>Slice</code> Block.</li> <li>Set the <code>start</code> index to <code>0</code> and the <code>end</code> index to <code>5</code>.</li> <li>Provide the input string: <code>\"Hello World\"</code>.</li> <li>The Block will output <code>\"Hello\"</code>.</li> </ul>"},{"location":"block-reference/Slice/#example-3-handle-an-empty-slice","title":"Example 3: Handle an empty slice","text":"<ul> <li>Create a <code>Slice</code> Block.</li> <li>Leave the default values for <code>start</code> and <code>end</code>.</li> <li>Provide the input list: <code>[1, 2, 3, 4]</code>.</li> <li>Since the <code>start</code> and <code>end</code> values are <code>0</code>, the Block will return an empty list <code>[]</code>.</li> </ul>"},{"location":"block-reference/Slice/#error-handling","title":"Error Handling","text":"<ul> <li>The <code>Slice</code> Block expects a valid list or string as input. If an invalid type (such as a number) is provided, the Block may raise an error.</li> <li>If the start or end index is out of range, Python's slicing behavior will handle this gracefully by adjusting the slice to fit within the bounds of the input.</li> </ul>"},{"location":"block-reference/Slice/#faq","title":"FAQ","text":"What happens if the <code>start</code> or <code>end</code> index is out of range? <p>Python handles out-of-range indexes gracefully. If the <code>start</code> or <code>end</code> index is beyond the length of the input, the Block will adjust the slice to fit within the available items. For example, if the input list has 4 items and the <code>end</code> index is set to 10, the Block will return up to the end of the list.</p> Can I use negative indexes for slicing? <p>Yes, the <code>Slice</code> Block supports negative indexes, which allow you to count from the end of the list or string. For example, setting the <code>start</code> index to <code>-3</code> and the <code>end</code> index to <code>-1</code> will slice the last two items from the input.</p> What happens if the <code>end</code> index is less than the <code>start</code> index? <p>If the <code>end</code> index is less than the <code>start</code> index, the Block will return an empty list or string, as there are no valid items to slice in this range.</p> Can I slice both lists and strings with this Block? <p>Yes, the <code>Slice</code> Block can handle both lists and strings. It will return a sliced portion of the input, whether it's a list or a string, based on the specified <code>start</code> and <code>end</code> indexes.</p>"},{"location":"block-reference/SplitString/","title":"SplitString","text":""},{"location":"block-reference/SplitString/#overview","title":"Overview","text":"<p>The <code>SplitString</code> Block is used to split a string into a list of substrings based on a configured separator. The separator can be customized, and an option is available to include the separator as part of the resulting substrings. By default, the separator is set to a newline character (<code>\\n</code>).</p> <p>This Block is useful for cases where you need to break a string into smaller parts, such as splitting a text file into lines or splitting a sentence into words.</p>"},{"location":"block-reference/SplitString/#description","title":"Description","text":"<p>Splits a string using the configured separator and outputs a list of the substrings</p>"},{"location":"block-reference/SplitString/#metadata","title":"Metadata","text":"<ul> <li>Category: Function</li> </ul>"},{"location":"block-reference/SplitString/#configuration-options","title":"Configuration Options","text":"Name Data Type Description Default Value separator <code>str</code> <code>\\n</code> include_separator <code>bool</code> <code>False</code>"},{"location":"block-reference/SplitString/#inputs","title":"Inputs","text":"Name Data Type Description string <code>str</code>"},{"location":"block-reference/SplitString/#outputs","title":"Outputs","text":"Name Data Type Description output <code>list[str]</code>"},{"location":"block-reference/SplitString/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/SplitString/#examples","title":"Example(s)","text":""},{"location":"block-reference/SplitString/#example-1-split-a-string-by-newline","title":"Example 1: Split a string by newline","text":"<ul> <li>Create a <code>SplitString</code> Block.</li> <li>Use the default separator (<code>\"\\n\"</code>).</li> <li>Provide the input string: <code>\"apple\\nbanana\\ncherry\"</code>.</li> <li>The output will be <code>[\"apple\", \"banana\", \"cherry\"]</code>.</li> </ul>"},{"location":"block-reference/SplitString/#example-2-split-a-string-by-a-comma","title":"Example 2: Split a string by a comma","text":"<ul> <li>Create a <code>SplitString</code> Block.</li> <li>Set the <code>separator</code> to <code>\",\"</code>.</li> <li>Provide the input string: <code>\"apple,banana,cherry\"</code>.</li> <li>The output will be <code>[\"apple\", \"banana\", \"cherry\"]</code>.</li> </ul>"},{"location":"block-reference/SplitString/#example-3-include-the-separator-in-the-result","title":"Example 3: Include the separator in the result","text":"<ul> <li>Set up a <code>SplitString</code> Block.</li> <li>Set the <code>separator</code> to <code>\" \"</code>, and enable <code>include_separator</code>.</li> <li>Provide the input string: <code>\"apple banana cherry\"</code>.</li> <li>The output will be <code>[\"apple \", \"banana \", \"cherry\"]</code>.</li> </ul>"},{"location":"block-reference/SplitString/#error-handling","title":"Error Handling","text":"<ul> <li>The <code>SplitString</code> Block expects a valid string as input. If a non-string value is passed, it may raise an error or cause unexpected behavior.</li> <li>If the separator is not found in the input string, the Block will return a list containing the original string as a single element.</li> </ul>"},{"location":"block-reference/SplitString/#faq","title":"FAQ","text":"What happens if the separator is not found in the input string? <p>If the separator is not found in the input string, the <code>SplitString</code> Block will return a list containing the entire original string as a single element.</p> Can I use multi-character separators? <p>Yes, the <code>SplitString</code> Block supports multi-character separators. For example, you can set the separator to <code>\" - \"</code> to split a string that contains spaces and hyphens.</p> What happens if the input string is empty? <p>If the input string is empty, the <code>SplitString</code> Block will return a list containing an empty string: <code>[\"\"]</code>.</p> How does the <code>include_separator</code> option work? <p>If the <code>include_separator</code> option is enabled, the separator will be appended to each substring, except for the last one. For example, splitting the string <code>\"apple,banana,cherry\"</code> with a comma separator and <code>include_separator</code> enabled will return <code>[\"apple,\", \"banana,\", \"cherry\"]</code>.</p>"},{"location":"block-reference/StringTemplate/","title":"StringTemplate","text":""},{"location":"block-reference/StringTemplate/#overview","title":"Overview","text":"<p>The <code>StringTemplate</code> Block allows you to generate a string by using a template and dynamically inserting values into it. This is useful when you want to build strings based on inputs with specific formatting. It uses the jinja2 templating engine to render the template.</p>"},{"location":"block-reference/StringTemplate/#description","title":"Description","text":""},{"location":"block-reference/StringTemplate/#metadata","title":"Metadata","text":"<ul> <li>Category: Misc</li> </ul>"},{"location":"block-reference/StringTemplate/#configuration-options","title":"Configuration Options","text":"Name Data Type Description Default Value template <code>str</code>"},{"location":"block-reference/StringTemplate/#inputs","title":"Inputs","text":"<p>No inputs available.</p>"},{"location":"block-reference/StringTemplate/#outputs","title":"Outputs","text":"Name Data Type Description string <code>str</code>"},{"location":"block-reference/StringTemplate/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/StringTemplate/#examples","title":"Example(s)","text":""},{"location":"block-reference/StringTemplate/#example-1-build-a-string-with-dynamic-values","title":"Example 1: Build a string with dynamic values","text":"<ul> <li>Create a <code>StringTemplate</code> Block.</li> <li>Set the <code>template</code> to <code>\"Hello, {{ name }}!\"</code>.</li> <li>Provide the input: <code>{\"name\": \"John\"}</code>.</li> <li>The Block will output: <code>\"Hello, John!\"</code>.</li> </ul>"},{"location":"block-reference/StringTemplate/#error-handling","title":"Error Handling","text":"<ul> <li>If the template contains invalid syntax, the Block will raise an error.</li> </ul>"},{"location":"block-reference/StringTemplate/#faq","title":"FAQ","text":"What happens if a required input is missing? <p>The Block will raise a <code>KeyError</code> if the template expects a variable that is not provided in the inputs.</p>"},{"location":"block-reference/StringTruncator/","title":"StringTruncator","text":""},{"location":"block-reference/StringTruncator/#overview","title":"Overview","text":"<p>The <code>StringTruncator</code> Block truncates a string input based on a specified token limit. This Block is useful when you need to limit the length of a string to a certain number of tokens, particularly in contexts where token usage is important, such as working with language models like GPT-3.5. The Block utilizes a tokenizer specific to the selected model to ensure accurate token counting and truncation.</p> <p>The default token limit is <code>100</code> tokens, and the default model for tokenization is <code>gpt-3.5-turbo</code>, but both can be configured.</p>"},{"location":"block-reference/StringTruncator/#description","title":"Description","text":"<p>takes in a string input and truncates it given a token limit</p>"},{"location":"block-reference/StringTruncator/#metadata","title":"Metadata","text":"<ul> <li>Category: Function</li> </ul>"},{"location":"block-reference/StringTruncator/#configuration-options","title":"Configuration Options","text":"Name Data Type Description Default Value max_token <code>int</code> <code>100</code> model_name <code>str</code> <code>gpt-3.5-turbo</code>"},{"location":"block-reference/StringTruncator/#inputs","title":"Inputs","text":"Name Data Type Description input_strings <code>str</code>"},{"location":"block-reference/StringTruncator/#outputs","title":"Outputs","text":"Name Data Type Description result <code>str</code>"},{"location":"block-reference/StringTruncator/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/StringTruncator/#examples","title":"Example(s)","text":""},{"location":"block-reference/StringTruncator/#example-1-truncate-a-string-with-the-default-token-limit","title":"Example 1: Truncate a string with the default token limit","text":"<ul> <li>Create a <code>StringTruncator</code> Block.</li> <li>Set the <code>max_token</code> to <code>100</code>.</li> <li>Provide the input string: <code>\"This is a long text that needs to be truncated based on the token limit.\"</code></li> <li>If the input exceeds 100 tokens, the Block will return a truncated version of the string. If it is shorter, the original string will be returned.</li> </ul>"},{"location":"block-reference/StringTruncator/#example-2-truncate-a-string-with-a-custom-token-limit","title":"Example 2: Truncate a string with a custom token limit","text":"<ul> <li>Set up a <code>StringTruncator</code> Block.</li> <li>Set the <code>max_token</code> to <code>50</code>.</li> <li>Provide the input string: <code>\"This is an even longer text that may need to be truncated based on a smaller token limit.\"</code></li> <li>The Block will truncate the string at the 50-token mark and return the truncated result.</li> </ul>"},{"location":"block-reference/StringTruncator/#example-3-handle-a-short-string-under-the-token-limit","title":"Example 3: Handle a short string under the token limit","text":"<ul> <li>Create a <code>StringTruncator</code> Block.</li> <li>Set the <code>max_token</code> to <code>100</code>.</li> <li>Provide a short input string: <code>\"This is a short string.\"</code></li> <li>The Block will return the original string, as it is under the token limit.</li> </ul>"},{"location":"block-reference/StringTruncator/#error-handling","title":"Error Handling","text":"<ul> <li>If the model name is invalid or unsupported, the Block will raise a <code>RuntimeError</code> indicating that the tokenizer could not be loaded.</li> <li>If an issue occurs during tokenization or truncation, the Block will raise a <code>RuntimeError</code> describing the problem.</li> </ul>"},{"location":"block-reference/StringTruncator/#faq","title":"FAQ","text":"What happens if the input string is shorter than the token limit? <p>If the input string contains fewer tokens than the specified token limit, the Block will return the original string without truncation.</p> Can I use a custom model for tokenization? <p>Yes, you can specify a custom model for tokenization by setting the <code>model_name</code> parameter. The Block will use the tokenizer associated with the model to accurately truncate the string based on the token limit.</p> What happens if the token limit is set too high? <p>If the token limit is higher than the number of tokens in the input string, the Block will simply return the original string. The token limit acts as an upper bound, not a minimum requirement.</p> Does this Block handle multi-byte characters? <p>Yes, the Block accounts for multi-byte characters through the tokenizer, ensuring that token counting and truncation are handled correctly for any type of text input, including those with multi-byte characters like emojis or non-Latin scripts.</p>"},{"location":"block-reference/TokenChunk/","title":"TokenChunk","text":""},{"location":"block-reference/TokenChunk/#overview","title":"Overview","text":"<p>The <code>TokenChunk</code> Block splits a document into chunks based on a fixed token size. This method ensures that each chunk has a consistent number of tokens, making it ideal for cases where precise control over chunk size is necessary, such as when working with models that have specific token limits. However, this method may split sentences or words, which could affect the coherence of the resulting chunks.</p> <p>This Block uses a tokenizer from the specified model to determine the token size and supports overlapping chunks for better continuity between consecutive chunks.</p>"},{"location":"block-reference/TokenChunk/#description","title":"Description","text":"<p>Parse the document text into chunks with a fixed token size.</p> <p>Args: - chunk_size: The number of tokens to include in each chunk. (default is 200) - chunk_overlap: The number of tokens that overlap between consecutive chunks. (default is 10) - separator: Default separator for splitting into words. (default is \" \")</p> <p>This chunking method is particularly useful when: - You need precise control over the size of each chunk. - You're working with models that have specific token limits. - You want to ensure consistent chunk sizes across different types of text.</p> <p>Note: While this method provides consistent chunk sizes, it may split sentences or even words, which could affect the coherence of each chunk. Consider the trade-off between consistent size and semantic coherence when using this method.</p>"},{"location":"block-reference/TokenChunk/#metadata","title":"Metadata","text":"<ul> <li>Category: Function</li> </ul>"},{"location":"block-reference/TokenChunk/#configuration-options","title":"Configuration Options","text":"Name Data Type Description Default Value chunk_size <code>int</code> <code>200</code> chunk_overlap <code>int</code> <code>10</code> separator <code>str</code> <code></code> model_name <code>str</code> <code>gpt-3.5-turbo</code>"},{"location":"block-reference/TokenChunk/#inputs","title":"Inputs","text":"Name Data Type Description text <code>str or list[str]</code>"},{"location":"block-reference/TokenChunk/#outputs","title":"Outputs","text":"Name Data Type Description result <code>list[str]</code>"},{"location":"block-reference/TokenChunk/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/TokenChunk/#examples","title":"Example(s)","text":""},{"location":"block-reference/TokenChunk/#example-1-chunk-a-document-with-default-settings","title":"Example 1: Chunk a document with default settings","text":"<ul> <li>Create a <code>TokenChunk</code> Block.</li> <li>Set the <code>chunk_size</code> to <code>200</code> tokens and <code>chunk_overlap</code> to <code>10</code>.</li> <li>Provide the input text: <code>\"This is a long document that needs to be split into chunks based on tokens.\"</code></li> <li>The Block will output chunks of the text, each containing approximately <code>200</code> tokens, with an overlap of <code>10</code> tokens between consecutive chunks.</li> </ul>"},{"location":"block-reference/TokenChunk/#example-2-customize-the-word-separator","title":"Example 2: Customize the word separator","text":"<ul> <li>Set up a <code>TokenChunk</code> Block.</li> <li>Set the <code>separator</code> to <code>\"\\n\"</code> to split text based on newline characters.</li> <li>Provide the input text with newline-separated sections: <code>\"Section 1: This is the first section.\\nSection 2: This is the second section.\"</code></li> <li>The Block will split the text based on newline characters and return token-based chunks.</li> </ul>"},{"location":"block-reference/TokenChunk/#example-3-handle-a-list-of-documents","title":"Example 3: Handle a list of documents","text":"<ul> <li>Create a <code>TokenChunk</code> Block.</li> <li>Provide a list of documents to be chunked:   <pre><code>[\n  \"Document 1: This is the first document.\",\n  \"Document 2: This is the second document.\"\n]\n</code></pre></li> <li>The Block will chunk each document individually and return the token-based chunks for each one.</li> </ul>"},{"location":"block-reference/TokenChunk/#error-handling","title":"Error Handling","text":"<ul> <li>If the tokenizer cannot be loaded for the specified model, the Block will raise a <code>RuntimeError</code> with an appropriate error message.</li> <li>If an issue occurs during the chunking process, the Block will raise a <code>RuntimeError</code> describing the problem.</li> <li>If no valid chunks are created, the Block will return a list containing an empty string.</li> </ul>"},{"location":"block-reference/TokenChunk/#faq","title":"FAQ","text":"What does the <code>chunk_size</code> parameter control? <p>The <code>chunk_size</code> parameter defines the number of tokens to include in each chunk. This allows you to ensure that each chunk stays within a specified token limit, which can be important for models with token restrictions.</p> What is the purpose of the <code>chunk_overlap</code> parameter? <p>The <code>chunk_overlap</code> parameter specifies the number of tokens that overlap between consecutive chunks. This overlap ensures continuity between chunks, which can be useful for maintaining context in language models.</p> Can I use custom models for tokenization? <p>Yes, you can specify a custom model for tokenization by setting the <code>model_name</code> parameter. The Block will use the tokenizer from the specified model to split the text into tokens.</p> What happens if the input text is too short to fill a chunk? <p>If the input text is shorter than the specified <code>chunk_size</code>, the Block will return the text as a single chunk without splitting it. If the text is empty or invalid, the Block will return an empty string.</p> Does this Block ensure that sentences are not split? <p>No, the <code>TokenChunk</code> Block focuses on creating chunks with a consistent token size. It may split sentences or even words depending on the token boundaries. If you need sentence preservation, consider using a sentence-based chunking method.</p>"},{"location":"block-reference/TypeSwitch/","title":"TypeSwitch","text":""},{"location":"block-reference/TypeSwitch/#overview","title":"Overview","text":"<p>The <code>TypeSwitch</code> Block allows you to select different outputs based on the schema of the input. This is useful when you need to handle multiple types of inputs and route them to different outputs based on their type.</p>"},{"location":"block-reference/TypeSwitch/#description","title":"Description","text":"<p>Checks the output schemas of the options and sends the input to the first option that matches</p>"},{"location":"block-reference/TypeSwitch/#metadata","title":"Metadata","text":"<ul> <li>Category: Misc</li> </ul>"},{"location":"block-reference/TypeSwitch/#configuration-options","title":"Configuration Options","text":"<p>No configuration options available.</p>"},{"location":"block-reference/TypeSwitch/#inputs","title":"Inputs","text":"Name Data Type Description item <code>Any</code>"},{"location":"block-reference/TypeSwitch/#outputs","title":"Outputs","text":"<p>No outputs available.</p>"},{"location":"block-reference/TypeSwitch/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/TypeSwitch/#examples","title":"Example(s)","text":""},{"location":"block-reference/TypeSwitch/#example-1-switch-based-on-input-type","title":"Example 1: Switch based on input type","text":"<ul> <li>Create a <code>TypeSwitch</code> Block.</li> <li>Define two options: one for strings and one for numbers.</li> <li>Provide the input <code>\"Hello\"</code> (string).</li> <li>The Block will send <code>\"Hello\"</code> to the string output.</li> </ul>"},{"location":"block-reference/TypeSwitch/#error-handling","title":"Error Handling","text":"<ul> <li>If the input does not match any defined schema, the Block will not send the input to any output.</li> </ul>"},{"location":"block-reference/TypeSwitch/#faq","title":"FAQ","text":"What happens if the input does not match any schema? <p>The Block will skip the input, and no outputs will be triggered.</p>"},{"location":"block-reference/UnpackList/","title":"UnpackList","text":""},{"location":"block-reference/UnpackList/#overview","title":"Overview","text":"<p>The <code>UnpackList</code> Block extracts elements from a list and sends them to the corresponding outputs. This is useful when you need to access individual elements of a list.</p>"},{"location":"block-reference/UnpackList/#description","title":"Description","text":"<p>Takes in a list and sends each item to the corresponding output</p>"},{"location":"block-reference/UnpackList/#metadata","title":"Metadata","text":"<ul> <li>Category: Misc</li> </ul>"},{"location":"block-reference/UnpackList/#configuration-options","title":"Configuration Options","text":"<p>No configuration options available.</p>"},{"location":"block-reference/UnpackList/#inputs","title":"Inputs","text":"Name Data Type Description list <code>list[Any]</code>"},{"location":"block-reference/UnpackList/#outputs","title":"Outputs","text":"<p>No outputs available.</p>"},{"location":"block-reference/UnpackList/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/UnpackList/#examples","title":"Example(s)","text":""},{"location":"block-reference/UnpackList/#example-1-unpack-a-list-into-individual-items","title":"Example 1: Unpack a list into individual items","text":"<ul> <li>Create an <code>UnpackList</code> Block.</li> <li>Set the <code>items</code> to output the first three elements of the list.</li> <li>Provide the input list: <code>[1, 2, 3, 4]</code>.</li> <li>The Block will send <code>1</code>, <code>2</code>, and <code>3</code> to the first three outputs.</li> </ul>"},{"location":"block-reference/UnpackList/#error-handling","title":"Error Handling","text":"<ul> <li>If the list contains more elements than the defined outputs, the extra elements will be ignored.</li> </ul>"},{"location":"block-reference/UnpackList/#faq","title":"FAQ","text":"What happens if the list has fewer elements than the outputs? <p>The outputs for the missing elements will not receive any values.</p>"},{"location":"block-reference/UnpackObject/","title":"UnpackObject","text":""},{"location":"block-reference/UnpackObject/#overview","title":"Overview","text":"<p>The <code>UnpackObject</code> Block extracts the properties of an object and sends them to the corresponding outputs. This is useful when you need to access individual properties of an object.</p>"},{"location":"block-reference/UnpackObject/#description","title":"Description","text":"<p>Takes in an object and sends each key-value pair to the corresponding output</p>"},{"location":"block-reference/UnpackObject/#metadata","title":"Metadata","text":"<ul> <li>Category: Misc</li> </ul>"},{"location":"block-reference/UnpackObject/#configuration-options","title":"Configuration Options","text":"<p>No configuration options available.</p>"},{"location":"block-reference/UnpackObject/#inputs","title":"Inputs","text":"Name Data Type Description object <code>dict[(str, Any)]</code>"},{"location":"block-reference/UnpackObject/#outputs","title":"Outputs","text":"<p>No outputs available.</p>"},{"location":"block-reference/UnpackObject/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/UnpackObject/#examples","title":"Example(s)","text":""},{"location":"block-reference/UnpackObject/#example-1-unpack-an-object-into-properties","title":"Example 1: Unpack an object into properties","text":"<ul> <li>Create an <code>UnpackObject</code> Block.</li> <li>Set the <code>properties</code> to output <code>name</code> and <code>age</code>.</li> <li>Provide the input object: <code>{\"name\": \"John\", \"age\": 30}</code>.</li> <li>The Block will send <code>\"John\"</code> to the <code>name</code> output and <code>30</code> to the <code>age</code> output.</li> </ul>"},{"location":"block-reference/UnpackObject/#error-handling","title":"Error Handling","text":"<ul> <li>If a property in the object is not mapped to an output, it will be ignored.</li> </ul>"},{"location":"block-reference/UnpackObject/#faq","title":"FAQ","text":"What happens if the object contains properties not defined in <code>properties</code>? <p>Those properties will be ignored unless explicitly defined in the Block\u2019s <code>properties</code>.</p>"},{"location":"block-reference/VectorSearch/","title":"VectorSearch","text":""},{"location":"block-reference/VectorSearch/#overview","title":"Overview","text":"<p>The <code>VectorSearch</code> Block performs a vector-based search over specified data spaces using embeddings to find the most relevant documents or items based on input queries. It uses an embeddings service to transform the input queries into vector embeddings, and searches for documents within the token limit and data space constraints.</p> <p>This Block is useful for retrieving relevant documents from large datasets using semantic search methods, and it supports token limits to ensure the search results are manageable within model constraints.</p>"},{"location":"block-reference/VectorSearch/#description","title":"Description","text":""},{"location":"block-reference/VectorSearch/#metadata","title":"Metadata","text":"<ul> <li>Category: Data</li> </ul>"},{"location":"block-reference/VectorSearch/#configuration-options","title":"Configuration Options","text":"Name Data Type Description Default Value topn <code>int</code> <code>10</code> token_limit <code>int</code> <code>2000</code> dataspace_ids <code>list[str] or Constant(value=None)</code> <code>[]</code>"},{"location":"block-reference/VectorSearch/#inputs","title":"Inputs","text":"Name Data Type Description queries <code>list[str]</code>"},{"location":"block-reference/VectorSearch/#outputs","title":"Outputs","text":"Name Data Type Description results <code>list[SearchResult]</code>"},{"location":"block-reference/VectorSearch/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/VectorSearch/#examples","title":"Example(s)","text":""},{"location":"block-reference/VectorSearch/#example-1-perform-a-vector-search-with-default-parameters","title":"Example 1: Perform a vector search with default parameters","text":"<ul> <li>Create a <code>VectorSearch</code> Block.</li> <li>Provide a list of queries, such as <code>[\"Find documents about AI ethics.\"]</code>.</li> <li>The Block will return the top 10 most relevant search results from the available data spaces, ranked by relevance.</li> </ul>"},{"location":"block-reference/VectorSearch/#example-2-search-across-multiple-data-spaces","title":"Example 2: Search across multiple data spaces","text":"<ul> <li>Set up a <code>VectorSearch</code> Block.</li> <li>Provide a list of <code>dataspace_ids</code> to specify which data spaces to search through.</li> <li>Provide a list of queries, such as <code>[\"Machine learning in healthcare.\"]</code>.</li> <li>The Block will perform a vector search across the provided data spaces and return the top search results.</li> </ul>"},{"location":"block-reference/VectorSearch/#example-3-search-with-a-custom-token-limit","title":"Example 3: Search with a custom token limit","text":"<ul> <li>Create a <code>VectorSearch</code> Block.</li> <li>Set the <code>token_limit</code> to <code>1000</code>.</li> <li>Provide a list of queries: <code>[\"AI and automation in manufacturing.\"]</code>.</li> <li>The Block will return search results while ensuring that the total token count for the results stays under the specified limit.</li> </ul>"},{"location":"block-reference/VectorSearch/#error-handling","title":"Error Handling","text":"<ul> <li>If the workspace is not defined, the Block will raise an error indicating that it can only be used within a workspace.</li> <li>If no results are found within the token limit, the Block will return an empty list.</li> </ul>"},{"location":"block-reference/VectorSearch/#faq","title":"FAQ","text":"What happens if the token limit is exceeded? <p>The Block will stop adding results once the token limit is reached. Any results that would cause the token count to exceed the limit will be excluded from the final output.</p> Can I search across multiple data spaces? <p>Yes, you can specify multiple <code>dataspace_ids</code> to search across different data spaces. If no <code>dataspace_ids</code> are provided, the search will be performed in the default data spaces associated with the workspace.</p> What happens if the query returns too many results? <p>The Block will sort the results by relevance (score) and return only the top results based on the <code>topn</code> parameter, which defaults to 10.</p> How does the Block handle duplicate results? <p>The Block checks for duplicates based on the document <code>id</code> and merges content from duplicate paths, ensuring that the final results are unique and comprehensive.</p>"},{"location":"block-reference/WindowChunk/","title":"WindowChunk","text":""},{"location":"block-reference/WindowChunk/#overview","title":"Overview","text":"<p>The <code>WindowChunk</code> Block splits a document into chunks where each chunk consists of a central sentence and its surrounding sentences based on a defined window size. This method captures context by including a specified number of sentences before and after the central sentence, ensuring that each chunk provides a windowed view of the text.</p> <p>This Block is particularly useful when you need to maintain local context around sentences, such as for tasks like summarization, entity extraction, or contextual analysis.</p>"},{"location":"block-reference/WindowChunk/#description","title":"Description","text":"<p>Sentence window chunk parser.</p> <p>Splits a document into Chunks Each chunk contains a window from the surrounding sentences.</p> <p>Args: window_size: The number of sentences on each side of a sentence to capture.</p>"},{"location":"block-reference/WindowChunk/#metadata","title":"Metadata","text":"<ul> <li>Category: Function</li> </ul>"},{"location":"block-reference/WindowChunk/#configuration-options","title":"Configuration Options","text":"Name Data Type Description Default Value window_size <code>int</code> <code>3</code>"},{"location":"block-reference/WindowChunk/#inputs","title":"Inputs","text":"Name Data Type Description text <code>str or list[str]</code>"},{"location":"block-reference/WindowChunk/#outputs","title":"Outputs","text":"Name Data Type Description result <code>list[str]</code>"},{"location":"block-reference/WindowChunk/#state-variables","title":"State Variables","text":"<p>No state variables available.</p>"},{"location":"block-reference/WindowChunk/#examples","title":"Example(s)","text":""},{"location":"block-reference/WindowChunk/#example-1-chunk-a-document-with-a-window-of-3-sentences","title":"Example 1: Chunk a document with a window of 3 sentences","text":"<ul> <li>Create a <code>WindowChunk</code> Block.</li> <li>Set the <code>window_size</code> to <code>3</code> (each chunk will include 3 sentences before and after the central sentence).</li> <li>Provide the input text:    <pre><code>\"Sentence 1. Sentence 2. Sentence 3. Sentence 4. Sentence 5. Sentence 6. Sentence 7.\"\n</code></pre></li> <li>The Block will output chunks, such as:   <pre><code>[\n  \"Sentence 1. Sentence 2. Sentence 3.\",\n  \"Sentence 2. Sentence 3. Sentence 4.\",\n  \"Sentence 3. Sentence 4. Sentence 5.\",\n  \"Sentence 4. Sentence 5. Sentence 6.\",\n  \"Sentence 5. Sentence 6. Sentence 7.\"\n]\n</code></pre></li> </ul>"},{"location":"block-reference/WindowChunk/#example-2-use-a-custom-window-size","title":"Example 2: Use a custom window size","text":"<ul> <li>Set up a <code>WindowChunk</code> Block.</li> <li>Set the <code>window_size</code> to <code>2</code>.</li> <li>Provide the input text:    <pre><code>\"The sky is blue. The sun is shining. The birds are singing. It's a beautiful day.\"\n</code></pre></li> <li>The Block will output windowed chunks, such as:   <pre><code>[\n  \"The sky is blue. The sun is shining.\",\n  \"The sun is shining. The birds are singing.\",\n  \"The birds are singing. It's a beautiful day.\"\n]\n</code></pre></li> </ul>"},{"location":"block-reference/WindowChunk/#example-3-handle-multiple-documents","title":"Example 3: Handle multiple documents","text":"<ul> <li>Create a <code>WindowChunk</code> Block.</li> <li>Provide a list of documents as input:   <pre><code>[\n  \"Document 1: Sentence 1. Sentence 2.\",\n  \"Document 2: Sentence 1. Sentence 2. Sentence 3.\"\n]\n</code></pre></li> <li>The Block will process each document and return windowed chunks for both:   <pre><code>[\n  [\"Sentence 1. Sentence 2.\"],\n  [\"Sentence 1. Sentence 2.\", \"Sentence 2. Sentence 3.\"]\n]\n</code></pre></li> </ul>"},{"location":"block-reference/WindowChunk/#error-handling","title":"Error Handling","text":"<ul> <li>If the input text is invalid or an error occurs during chunking, the Block will raise a <code>RuntimeError</code> with a descriptive error message.</li> <li>If no valid chunks are generated, the Block will return a list containing an empty string.</li> </ul>"},{"location":"block-reference/WindowChunk/#faq","title":"FAQ","text":"What does the <code>window_size</code> parameter control? <p>The <code>window_size</code> parameter specifies how many sentences before and after the central sentence should be included in each chunk. A larger window size provides more context for each chunk, while a smaller window size results in tighter sentence groups.</p> What happens if the document is too short to fill a chunk? <p>If the document is shorter than the specified window size, the Block will return smaller chunks that include only the available sentences. For example, if a document has 2 sentences and the window size is 3, the Block will still return the entire document in one chunk.</p> Can I use this Block for multiple documents at once? <p>Yes, the <code>WindowChunk</code> Block can process a list of documents. Each document will be split into windowed chunks independently, and the Block will return the results for each document as a list of chunks.</p> Does this Block ensure that sentences are not split? <p>Yes, the <code>WindowChunk</code> Block is designed to preserve complete sentences. It chunks the text based on full sentences, ensuring that no sentence is split across chunks.</p>"},{"location":"concepts/channels/","title":"Channels","text":""},{"location":"concepts/channels/#channels-in-flow-system-overview","title":"Channels in Flow System: Overview","text":"<p>In this flow architecture, channels are pathways that track how data moves between blocks. Channels ensure that outputs from one part of the system can be correctly processed and synchronized with inputs in another part. When blocks emit multiple values, such as through iterations or conditional logic, channels manage the relationship between these values and ensure they are handled correctly downstream.</p>"},{"location":"concepts/channels/#key-components-of-channels","title":"Key Components of Channels:","text":"<ol> <li> <p>Output Channels:</p> <ul> <li>Tracking and Versioning: When a block outputs values, it does so through a channel that assigns indexes to each value. The first item output will have an index of <code>0</code>, the second <code>1</code>, and so on. These indexes are critical because any subsequent inputs must match the output's index to ensure the correct processing of related data.</li> <li>Scope of Values: When a block processes multiple values (e.g., via a loop like a <code>forEach</code> block), the system ensures that corresponding outputs align with their associated input indexes. For example, if a list of five items is processed, each item is assigned an index (0 to 4). As those items pass through other blocks, they are tracked by these indexes to maintain alignment.</li> </ul> </li> <li> <p>Input Channels:</p> <ul> <li>Collecting and Matching Inputs: Channels help collect multiple inputs from various blocks and ensure they align by index. For instance, if a block receives several inputs (e.g., five files), the system waits until all necessary inputs have arrived before proceeding, ensuring each input corresponds to the correct output based on its channel and index.</li> </ul> </li> <li> <p>Close Events:</p> <ul> <li>Channels can issue a close event when all expected values have been output or processed. This event signals the end of data transmission on that channel, allowing downstream blocks to act accordingly, such as by aggregating the results or triggering final operations.</li> </ul> </li> <li> <p>Descope Operations:</p> <ul> <li>Sometimes, values need to be \"descope,\" meaning they are removed from a particular channel or context. This allows values to be used in other parts of the flow that don\u2019t rely on the channel's context. The descope operation can be applied to specific values to remove them from the channel\u2019s tracking without affecting others, maintaining control over which values are subject to channel indexing.</li> <li>If a block like <code>forEach</code> needs to exit after processing all its items, it uses descope mechanisms to remove items from the current channel and ensure they\u2019re treated as fully processed.</li> </ul> </li> </ol>"},{"location":"concepts/channels/#handling-multiple-flows-and-inputs","title":"Handling Multiple Flows and Inputs","text":"<ul> <li>Root Channel: When a flow begins, a root channel is created to track all inputs. If the flow has multiple runs, each run will have a different index, ensuring that different invocations of the flow don\u2019t interfere with each other.</li> <li>Collect Block: The <code>collect</code> block can aggregate values from multiple channels and output a combined result, ensuring that values from different paths or inputs can be synchronized and processed together.</li> </ul>"},{"location":"concepts/channels/#custom-blocks-and-channels","title":"Custom Blocks and Channels","text":"<ul> <li>Developers can create custom blocks that leverage channels, either by emitting data into channels or receiving data from channels. For instance, a block can output several items on a channel, and a downstream block can handle those outputs based on their indexes.</li> <li>Channels also support custom logic for managing complex flows, such as when a block needs to handle multiple inputs and ensure they are all in sync before processing can continue.</li> </ul>"},{"location":"concepts/channels/#use-case-example","title":"Use Case Example","text":"<ul> <li>Iterative Processing: A list of items passes through a <code>forEach</code> block. The block outputs each item with an index (e.g., 0 to 4). A downstream block that processes these items must ensure the index of incoming data matches its corresponding output. If not, the system will wait until all items with matching indexes are present before proceeding, ensuring consistent data flow and synchronization.</li> <li>De-Scope for Conditional Logic: In a case where conditional branches are used, the system may need to \"descope\" values when merging data from different paths. If items were initially processed through a specific channel but must be merged later, removing them from the channel context allows for more flexible processing.</li> </ul>"},{"location":"concepts/channels/#challenges-and-considerations","title":"Challenges and Considerations","text":"<ul> <li>Scalability: Early versions of the system tracked the entire history of values, which could become unmanageable over time, especially for large datasets or prolonged flows. The newer approach focuses on tracking only essential parts of the flow, significantly improving scalability.</li> <li>Complexity: Channels introduce complexity, especially in scenarios involving multiple inputs, nested channels, or descope operations. It is crucial to design intuitive mechanisms for users to understand and manage channels without overwhelming them.</li> </ul>"},{"location":"concepts/channels/#faq-channels-in-the-flow-system","title":"FAQ: Channels in the Flow System","text":"1. What is a Channel? <p>A Channel is a mechanism that tracks how data flows between blocks in a system. It ensures that outputs and inputs are synchronized by associating them with indexes, which makes it easier to track the relationship between data as it moves through different parts of the flow.</p> 2. Why are Channels necessary in the flow system? <p>Channels are essential for:</p> <ul> <li>Ensuring that data passing through different blocks can be tracked, especially when dealing with multiple outputs (e.g., iterations in a loop).</li> <li>Allowing different data sources to be processed simultaneously but kept in sync through indexing.</li> <li>Handling complex flows that involve conditional logic or multiple branches, where synchronization of data is critical.</li> </ul> 3. How does indexing in a Channel work? <p>Each value that a block outputs through a Channel is assigned an index. For example, if a block emits five values, they will be indexed as <code>0, 1, 2, 3, 4</code>. When another block downstream processes these values, it uses the indexes to ensure that corresponding inputs and outputs are aligned correctly.</p> 4. What happens if indexes don't match? <p>If the indexes of inputs do not match, the system will wait until all required values with the same index are available before proceeding. For example, if a block is expecting <code>index 1</code> to arrive from two different inputs but only one input arrives, it won\u2019t process until the second input also delivers <code>index 1</code>.</p> 5. What is a \u201cclose event\u201d in a Channel? <p>A close event signals that no more data will be sent through a particular Channel. After this event, any blocks listening to the Channel know that they can finalize processing or aggregation of the data that has been received.</p> 6. How are Channels scoped? <p>When data passes through a block, it retains the scope of the Channel it was initially part of. If a block processes data from different sources (such as using a <code>forEach</code> loop), the system ensures that only data from the same scope (i.e., same Channel and index) is processed together. This avoids mismatched data being processed.</p> 7. What is \u201cdescope\u201d and why is it important? <p>Descope is the process of removing a value from the context of a Channel. When you descope a value, it is no longer tied to its original Channel, allowing it to be processed or used outside of that context. Descope operations are necessary when:</p> <ul> <li>You want to combine data from different Channels or inputs.</li> <li>Data has passed through conditional logic and now needs to be merged.</li> <li>You need to process data without the restrictions imposed by its original Channel.</li> </ul> 8. Can I remove a value from all Channels when using descope? <p>Yes, when you descope a value, it can be removed from all Channel contexts if desired. Alternatively, you can descope it from only the most recent or specific Channels, depending on how the descope block is configured.</p> 9. What is the difference between an input Channel and an output Channel? <ul> <li>Input Channel: Receives data from other blocks. It listens for inputs and ensures that data is synchronized based on the Channel\u2019s index.</li> <li>Output Channel: Emits data from a block, associating each output with an index, which allows downstream blocks to synchronize their inputs accordingly.</li> </ul> 10. How do output Channels handle multiple messages or values? <p>An output Channel can emit multiple values, such as when processing a list of items. Each value is assigned an index to ensure downstream blocks know which inputs correspond to which outputs. For example, if a <code>forEach</code> block outputs five values, each value will have an index (e.g., <code>0, 1, 2, 3, 4</code>), ensuring downstream blocks process them in sync.</p> 11. What is a root Channel? <p>A root Channel is the main Channel created when the flow system starts. All initial inputs to the system are placed inside the root Channel. As the flow progresses, additional Channels may be created to track specific data paths or logic branches, but all of them ultimately relate to the root Channel.</p> 12. How do custom blocks work with Channels? <p>Custom blocks can be programmed to:</p> <ul> <li>Emit data into a Channel (output).</li> <li>Receive data from a Channel (input).</li> <li>Handle descope logic or close events.</li> </ul> <p>Developers creating custom blocks need to ensure they manage Channels correctly, especially when dealing with multiple inputs, outputs, or asynchronous operations.</p> 13. What happens if I process data from multiple Channels? <p>When a block needs to process data from multiple Channels, it waits until all relevant inputs are available, based on their indexes. The system ensures that only data with matching indexes is processed together, preventing mismatches between values that should be synchronized.</p> 14. What is the collect block and how does it work? <p>The collect block is a special block used to aggregate data from multiple inputs or Channels. It waits for all expected values (based on the Channel\u2019s index) before combining them into a single output. This is particularly useful when multiple paths of a flow converge and need to be synchronized.</p> 15. How can I debug Channels in my flow? <p>To debug Channels:</p> <ul> <li>Use visual debugging tools that show the flow of data through Channels.</li> <li>Ensure that you are correctly matching inputs and outputs by checking their indexes.</li> <li>Monitor when close events occur to verify that all data has been processed before the Channel is closed.</li> </ul> 16. What happens if my flow spans across multiple invocations? <p>Each time a flow is invoked, a new root Channel is created with a unique index. If you want to combine data from different invocations, you\u2019ll need to either descope the values or use a block like <code>collect</code> to gather inputs from different Channels.</p> 17. What are some common issues developers face with Channels? <ul> <li>Index mismatches: If blocks receive data with different indexes, they won\u2019t process until matching values are available.</li> <li>Overcomplicating scoping: Sometimes Channels can become too nested or complex, making it hard to manage and track values.</li> <li>Forgetting to descope: If values from different parts of the flow need to be merged, forgetting to descope them can lead to mismatched or unprocessed data.</li> </ul> 18. How can I visualize the flow and the Channels involved? <p>There are tools or visual debuggers that can display the Channels in use, showing which values are scoped within which Channel. Some systems may provide color-coding or hierarchical views to show how values propagate through different Channels.</p> 19. Can I programmatically control when Channels are created or closed? <p>Yes, custom blocks or specific flow control mechanisms allow you to manage the lifecycle of Channels. You can program when to create a new Channel, emit a close event, or descope values programmatically to control how the flow behaves dynamically.</p> 20. What is a real-world example of using Channels effectively? <p>Suppose you are processing a list of files in a <code>forEach</code> block. Each file gets processed independently, and the results are output through an output Channel. Downstream blocks ensure that the results are synchronized based on the file index. When all files are processed, a close event is sent, and a <code>collect</code> block aggregates the results for final processing, ensuring all files are handled before moving on.</p> 21. Can Channels be nested, and how do they interact? <p>Yes, Channels can be nested. In these cases, a value may be scoped to multiple Channels. When descoping a value, you can remove it from the innermost Channel (the \u201cleaf\u201d Channel) while leaving it in the outer Channels. This allows for flexible control of data as it passes through various stages of the flow.</p> 22. How can I optimize the performance of Channels in large flows? <ul> <li>Minimize unnecessary scoping: Only create Channels when needed to prevent overloading the system with too many Channels.</li> <li>Use descope judiciously: Make sure you descope values that no longer need to be tied to a specific Channel to avoid unnecessary tracking.</li> <li>Monitor long-running flows: If a flow runs for a long time or processes thousands of items, ensure the system is optimized to handle the Channel\u2019s lifecycle efficiently.</li> </ul>"},{"location":"concepts/channels/#conclusion","title":"Conclusion","text":"<p>Channels are a fundamental part of controlling and synchronizing data in a flow system. Understanding how to properly use, manage, and debug Channels is crucial for building scalable, reliable, and efficient applications.</p>"},{"location":"concepts/blocks/","title":"Overview","text":"<p>This document covers the key concepts that underpin blocks in the SmartSpace platform. Blocks are the building blocks of workflows in SmartSpace, and understanding the various concepts around their structure, functionality, and behavior is essential for making the most of the platform.</p>"},{"location":"concepts/blocks/#1-what-are-blocks","title":"1. What are Blocks?","text":"<p>In SmartSpace, blocks represent individual units of logic or tasks that execute within a workflow. Each block is a self-contained entity with its own inputs, outputs, states, and functionality, and it interacts with other blocks through defined interfaces.</p> <p>Blocks are designed to be reusable and modular, allowing complex workflows to be built by combining multiple blocks together. They encapsulate a specific piece of logic, such as counting items, performing mathematical operations, or handling more advanced processing like data collection or transformation.</p>"},{"location":"concepts/blocks/#2-block-interfaces","title":"2. Block Interfaces","text":"<p>Every block in SmartSpace exposes an interface. The interface defines: - The block's inputs and outputs, including the type and structure of data that the block can accept or produce. - The state the block maintains across executions. - The metadata that describes the block's functionality and behavior.</p> <p>The block interface serves as a contract for how the block interacts with the rest of the workflow. When a block is instantiated, its interface allows other blocks or users to understand its available functionalities and how to connect to it.</p>"},{"location":"concepts/blocks/#example-interface","title":"Example Interface:","text":"<pre><code>{\n  \"inputs\": {\n    \"x\": \"int\",\n    \"y\": \"int\"\n  },\n  \"outputs\": {\n    \"result\": \"int\"\n  },\n  \"state\": {\n    \"total\": \"int\"\n  },\n  \"metadata\": {\n    \"description\": \"Multiplies two numbers\"\n  }\n}\n</code></pre>"},{"location":"concepts/blocks/#3-inputs-outputs-and-pins","title":"3. Inputs, Outputs, and Pins","text":"<p>Blocks interact with each other via pins, which represent the connection points for inputs and outputs. Pins allow data to flow between blocks during the execution of a workflow.</p>"},{"location":"concepts/blocks/#inputs","title":"Inputs:","text":"<p>An input is data provided to a block to perform its task. Inputs can be primitive types (like <code>int</code>, <code>str</code>, etc.) or more complex types (like lists or dictionaries). Inputs are bound to input pins.</p>"},{"location":"concepts/blocks/#outputs","title":"Outputs:","text":"<p>Outputs are the result of a block's execution. They are bound to output pins and can send data to other blocks in the workflow. Outputs can be a single value or a collection of values.</p>"},{"location":"concepts/blocks/#31-pin-types","title":"3.1 Pin Types","text":"<p>Pins are of three main types: - Single Pins (PinType.SINGLE): Handle individual values, such as a single integer or string. - List Pins (PinType.LIST): Handle lists of values, such as a list of integers. - Dictionary Pins (PinType.DICTIONARY): Handle key-value pairs where keys are strings and values are complex data types like objects or lists.</p> <p>Each pin type controls how inputs and outputs are structured and connected.</p>"},{"location":"concepts/blocks/#4-states","title":"4. States","text":"<p>Blocks can maintain state, which represents persistent data stored within the block across different executions. States allow a block to retain information between multiple workflow runs.</p> <p>State variables are defined using the <code>State</code> annotation and are useful for keeping track of counters, aggregated data, or other information that needs to be preserved.</p>"},{"location":"concepts/blocks/#example","title":"Example:","text":"<pre><code>class Accumulator(Block):\n    total: Annotated[int, State(step_id=\"accumulate\", input_ids=[\"items\"])] = 0\n</code></pre> <p>In this example, the <code>total</code> state retains the sum of items processed across multiple steps in the workflow.</p>"},{"location":"concepts/blocks/#5-ports","title":"5. Ports","text":"<p>Ports are logical groupings of inputs and outputs that allow blocks to manage data flow and interaction. A block can have multiple ports, each responsible for handling different inputs and outputs. Ports can be: - Single (PortType.SINGLE): A port managing a single input/output pair. - List (PortType.LIST): A port handling a list of inputs or outputs. - Dictionary (PortType.DICTIONARY): A port managing key-value pairs for inputs or outputs.</p> <p>Ports provide an additional level of structure to the inputs and outputs of a block. They make it easier to manage complex blocks that handle multiple data flows.</p>"},{"location":"concepts/blocks/#6-steps-and-callbacks","title":"6. Steps and Callbacks","text":"<p>Steps and Callbacks are key concepts in defining a block\u2019s behavior.</p>"},{"location":"concepts/blocks/#steps","title":"Steps:","text":"<p>A step is a function that represents a unit of work performed by the block. It is marked with the <code>@step</code> decorator and typically contains the core logic of the block. Steps are asynchronous (<code>async</code> functions) and can interact with the block's inputs, outputs, and states.</p>"},{"location":"concepts/blocks/#example_1","title":"Example:","text":"<pre><code>class Multiply(Block):\n    @step(output_name=\"result\")\n    async def multiply(self, x: int, y: int) -&gt; int:\n        return x * y\n</code></pre>"},{"location":"concepts/blocks/#callbacks","title":"Callbacks:","text":"<p>A callback is a function that is triggered in response to an event, such as receiving data from another block or completing an action. Callbacks are marked with the <code>@callback</code> decorator and are also asynchronous.</p>"},{"location":"concepts/blocks/#example_2","title":"Example:","text":"<pre><code>class Collect(Block):\n    @callback()\n    async def collect(self, result: int):\n        print(f\"Collected result: {result}\")\n</code></pre>"},{"location":"concepts/blocks/#7-tools","title":"7. Tools","text":"<p>Tools are special types of reusable functionality within a block. A tool allows blocks to perform specific tasks and can be dynamically called with different inputs during a block\u2019s execution. Tools are usually associated with the processing logic applied to inputs.</p>"},{"location":"concepts/blocks/#example_3","title":"Example:","text":"<pre><code>class Operation(Tool):\n    def run(self, item: int) -&gt; int:\n        return item * 2\n</code></pre> <p>The <code>Operation</code> tool is used to double the value of each input item. Tools make blocks more flexible and reusable, as the same tool can be applied to different sets of data.</p>"},{"location":"concepts/blocks/#8-block-metadata","title":"8. Block Metadata","text":"<p>Metadata provides descriptive information about a block, such as its category, a human-readable description, and other attributes that help users understand the purpose and behavior of the block.</p> <p>Metadata is added using the <code>@metadata</code> decorator, and it allows blocks to be categorised and documented within the SmartSpace system.</p>"},{"location":"concepts/blocks/#example_4","title":"Example:","text":"<pre><code>@metadata(\n    category=BlockCategory.FUNCTION,\n    description=\"Counts the number of items in a list.\"\n)\nclass Count(Block):\n    ...\n</code></pre> <p>Metadata is crucial for enabling users to search, categorise, and understand blocks within larger workflows.</p>"},{"location":"concepts/blocks/#9-dynamic-ports","title":"9. Dynamic Ports","text":"<p>Some blocks may need to handle dynamic numbers of inputs and outputs that are only known at runtime. These are called dynamic ports. Dynamic ports allow a block to accept or produce data based on variable conditions or inputs.</p>"},{"location":"concepts/blocks/#example_5","title":"Example:","text":"<pre><code>class DynamicBlock(Block):\n    dynamic_inputs: list[Input[int]]\n    dynamic_outputs: dict[str, Output[int]]\n\n    @step()\n    async def process(self):\n        for input_value in self.dynamic_inputs:\n            output_value = input_value * 2\n            self.dynamic_outputs[str(input_value)].send(output_value)\n</code></pre> <p>In the example above, <code>dynamic_inputs</code> and <code>dynamic_outputs</code> can handle varying numbers of inputs and outputs.</p>"},{"location":"concepts/blocks/#10-error-handling-in-blocks","title":"10. Error Handling in Blocks","text":"<p>Error handling in blocks is done via the <code>BlockError</code> class. This allows blocks to raise and communicate errors during execution. Blocks can define an <code>error</code> output pin that emits an error message when a failure occurs.</p>"},{"location":"concepts/blocks/#example_6","title":"Example:","text":"<pre><code>class BlockError(Exception):\n    def __init__(self, message: str, data: Any = None):\n        self.message = message\n        self.data = data\n\nclass MyBlock(Block):\n    error: Output[BlockError]\n\n    @step()\n    async def risky_operation(self):\n        try:\n            # risky logic here\n        except Exception as e:\n            self.error.send(BlockError(message=str(e)))\n</code></pre> <p>Error handling is essential for creating robust blocks that can gracefully handle unexpected situations.</p>"},{"location":"concepts/blocks/#conclusion","title":"Conclusion","text":"<p>The concepts around blocks in SmartSpace, such as inputs, outputs, states, ports, tools, and metadata, provide a structured and flexible system for creating reusable components in workflows. Understanding these concepts is key to building powerful, dynamic, and scalable workflows using the SmartSpace platform.</p>"},{"location":"concepts/blocks/connections/","title":"Connections","text":"<p>Connections in SmartSpace are the means by which blocks communicate and exchange data during the execution of workflows. By understanding how connections work, you can efficiently design workflows that ensure proper data flow between blocks, enabling complex tasks to be performed.</p>"},{"location":"concepts/blocks/connections/#1-what-are-connections","title":"1. What are Connections?","text":"<p>A connection in SmartSpace links the outputs of one block to the inputs of another, allowing data to be passed from one block to another as part of a workflow. Connections are the backbone of how workflows operate, enabling blocks to collaborate and share data efficiently.</p> <p>Connections ensure that: - The output from a source block is available to the destination block\u2019s input. - Blocks execute in the correct sequence based on the availability of required inputs.</p>"},{"location":"concepts/blocks/connections/#2-types-of-connections","title":"2. Types of Connections","text":""},{"location":"concepts/blocks/connections/#direct-connections","title":"Direct Connections","text":"<p>Direct connections are the simplest form of connection, linking a specific output of one block to the input of another block. Once a block has finished processing, the data it produces is passed directly to the next block in the workflow.</p> <p>For example, if Block A outputs a list of numbers and Block B calculates the sum of that list, the direct connection would link Block A\u2019s output to Block B\u2019s input.</p>"},{"location":"concepts/blocks/connections/#dynamic-connections","title":"Dynamic Connections","text":"<p>Dynamic connections are more flexible and are established based on runtime conditions. These connections allow for workflows to adapt based on input conditions, supporting scenarios where the number or type of inputs and outputs is not fixed.</p> <p>For example, a block could dynamically decide to send outputs to different blocks based on the data it processes.</p>"},{"location":"concepts/blocks/connections/#3-connection-elements","title":"3. Connection Elements","text":"<p>Connections are made up of pins and channels, which define how data flows between blocks.</p>"},{"location":"concepts/blocks/connections/#31-pins","title":"3.1 Pins","text":"<p>Pins are the endpoints of connections, representing the input and output points on a block. There are two main types of pins:</p> <ul> <li>Input Pins: Receive data from another block.</li> <li>Output Pins: Send data to another block.</li> </ul> <p>Pins can be of several types:</p> <ul> <li>Single Pins (PinType.SINGLE): Represent a single input or output value.</li> <li>List Pins (PinType.LIST): Represent a collection of values (e.g., a list of integers).</li> <li>Dictionary Pins (PinType.DICTIONARY): Represent key-value pairs for handling more complex input/output structures.</li> </ul>"},{"location":"concepts/blocks/connections/#32-channels","title":"3.2 Channels","text":"<p>Channels represent a flow of data between two pins. Channels carry data between the output pin of one block and the input pin of another. Channels can transmit individual data items or continuous streams, depending on the type of connection.</p>"},{"location":"concepts/blocks/connections/#4-data-flow","title":"4. Data Flow","text":"<p>The data flow in a SmartSpace workflow is the movement of data between blocks through connections. When a block completes its processing, it sends its outputs through output pins via the established connection to the next block\u2019s input pins.</p> <ul> <li>Synchronous Data Flow: Data flows from one block to the next in sequence, ensuring that blocks execute in a well-defined order.</li> <li>Asynchronous Data Flow: Blocks may execute and send data independently of one another, especially when channels are used to stream data.</li> </ul>"},{"location":"concepts/blocks/connections/#5-establishing-connections","title":"5. Establishing Connections","text":"<p>Connections between blocks are established by linking output pins of one block to input pins of another. In most cases, this process is straightforward and involves connecting matching input and output types (e.g., an integer output connects to an integer input).</p>"},{"location":"concepts/blocks/connections/#6-managing-multiple-connections","title":"6. Managing Multiple Connections","text":"<p>In complex workflows, blocks may have multiple inputs and outputs. Managing these connections properly ensures that data flows correctly between all the blocks in the workflow.</p>"},{"location":"concepts/blocks/connections/#one-to-one","title":"One-to-One:","text":"<p>In a one-to-one connection, a single output pin connects to a single input pin.</p>"},{"location":"concepts/blocks/connections/#one-to-many","title":"One-to-Many:","text":"<p>In a one-to-many connection, a single output pin connects to multiple input pins, distributing the same data to multiple blocks. This is useful when a single output needs to be consumed by several blocks.</p>"},{"location":"concepts/blocks/connections/#many-to-one","title":"Many-to-One:","text":"<p>In a many-to-one connection, multiple output pins connect to a single input pin. The input block will receive data from multiple sources, often using aggregation or merging logic to process the data.</p>"},{"location":"concepts/blocks/connections/#conclusion","title":"Conclusion","text":"<p>Connections are the essential links between blocks in SmartSpace workflows, enabling data to flow from one block to another. By understanding how to establish and manage connections, how data flows through pins and channels, and how to handle complex workflows with multiple connections, you can design robust and scalable workflows that efficiently accomplish complex tasks. Error handling ensures that workflows remain stable even when unexpected issues arise.</p>"},{"location":"concepts/blocks/custom-blocks-building/","title":"Custom Blocks","text":"<p>This guide will walk you through the steps of creating new blocks for the SmartSpace platform using the provided core block framework. Blocks are reusable components that perform specific tasks in workflows and can be configured with various inputs, outputs, and states.</p>"},{"location":"concepts/blocks/custom-blocks-building/#1-block-structure","title":"1. Block Structure","text":"<p>Blocks are Python classes that inherit from the <code>Block</code> base class and optionally from other generic types to support various input and output types. Each block should:</p> <ul> <li>Contain inputs and outputs as typed attributes.</li> <li>Implement logic in steps or callbacks.</li> <li>Optionally use states to store intermediate or persistent values.</li> <li>Provide metadata for categorisation and description.</li> </ul>"},{"location":"concepts/blocks/custom-blocks-building/#2-creating-a-simple-block","title":"2. Creating a Simple Block","text":"<p>To create a new block, define a class that extends <code>Block</code> and optionally a generic type if needed. You can define the block\u2019s inputs, outputs, and internal logic within the class.</p>"},{"location":"concepts/blocks/custom-blocks-building/#example","title":"Example:","text":"<pre><code>from smartspace.core import Block, step\n\nclass Count(Block):\n    @step(output_name=\"output\")\n    async def count(self, items: list[Any]) -&gt; int:\n        return len(items)\n</code></pre> <p>In this example, the <code>Count</code> block takes a list of items and outputs the count.</p>"},{"location":"concepts/blocks/custom-blocks-building/#3-adding-metadata","title":"3. Adding Metadata","text":"<p>You can add metadata to a block to provide descriptive information such as the block\u2019s category, description, or other attributes that are important for its usage in the SmartSpace system. Use the <code>@metadata</code> decorator for this purpose.</p>"},{"location":"concepts/blocks/custom-blocks-building/#example_1","title":"Example:","text":"<pre><code>from smartspace.core import Block, metadata, step\nfrom smartspace.enums import BlockCategory\n\n@metadata(\n    category=BlockCategory.FUNCTION,\n    description=\"Counts the number of items in a list.\"\n)\nclass Count(Block):\n    @step(output_name=\"output\")\n    async def count(self, items: list[Any]) -&gt; int:\n        return len(items)\n</code></pre> <p>The <code>@metadata</code> decorator adds useful information for developers and users of the block.</p>"},{"location":"concepts/blocks/custom-blocks-building/#4-working-with-input-and-output-pins","title":"4. Working with Input and Output Pins","text":"<p>Blocks interact with other blocks via input and output pins. These pins can be single values, lists, or dictionaries. You can define inputs and outputs using Python type annotations.</p>"},{"location":"concepts/blocks/custom-blocks-building/#defining-inputs","title":"Defining Inputs:","text":"<p><pre><code>from smartspace.core import Block, step\n\nclass Count(Block):\n    @step(output_name=\"output\")\n    async def count(self, items: list[Any]) -&gt; int:\n        return len(items)\n</code></pre> Here, the <code>items</code> parameter is the input, which is a list of any type.</p>"},{"location":"concepts/blocks/custom-blocks-building/#defining-outputs","title":"Defining Outputs:","text":"<p>Outputs are defined similarly to inputs but are typically sent using the <code>send</code> method. <pre><code>class Sum(Block):\n    total: Output[int]\n\n    @step()\n    async def sum(self, items: list[int]):\n        self.total.send(sum(items))\n</code></pre></p>"},{"location":"concepts/blocks/custom-blocks-building/#5-working-with-states","title":"5. Working with States","text":"<p>States in SmartSpace blocks store values that persist across the execution of the block. You can define state variables using the <code>State</code> annotation.</p>"},{"location":"concepts/blocks/custom-blocks-building/#example_2","title":"Example:","text":"<pre><code>from typing import Annotated\nfrom smartspace.core import Block, step, State\n\nclass Accumulator(Block):\n    total: Annotated[int, State(step_id=\"accumulate\", input_ids=[\"items\"])] = 0\n\n    @step()\n    async def accumulate(self, items: list[int]):\n        self.total += sum(items)\n</code></pre> <p>In this example, the <code>total</code> variable persists across multiple calls to the <code>accumulate</code> method.</p>"},{"location":"concepts/blocks/custom-blocks-building/#6-defining-block-functions","title":"6. Defining Block Functions","text":"<p>You can define block functions using the <code>@step</code> and <code>@callback</code> decorators. Steps are core functions of the block, while callbacks are executed in response to specific events.</p>"},{"location":"concepts/blocks/custom-blocks-building/#defining-a-step","title":"Defining a Step:","text":"<p><pre><code>class Multiply(Block):\n    @step(output_name=\"result\")\n    async def multiply(self, x: int, y: int) -&gt; int:\n        return x * y\n</code></pre> Steps are async functions that execute the main logic of the block.</p>"},{"location":"concepts/blocks/custom-blocks-building/#defining-a-callback","title":"Defining a Callback:","text":"<p><pre><code>class MultiplyAndStore(Block):\n    @step()\n    async def multiply(self, x: int, y: int):\n        result = x * y\n        await self.store_result(result)\n\n    @callback()\n    async def store_result(self, result: int):\n        print(f\"Result: {result}\")\n</code></pre> Callbacks allow you to define actions that respond to the results of other steps or tools.</p>"},{"location":"concepts/blocks/custom-blocks-building/#7-handling-dynamic-inputs-and-outputs","title":"7. Handling Dynamic Inputs and Outputs","text":"<p>In some cases, blocks may need to dynamically handle inputs and outputs at runtime. For example, a block could process a variable number of inputs or outputs. You can define dynamic ports using lists or dictionaries of inputs and outputs.</p>"},{"location":"concepts/blocks/custom-blocks-building/#example_3","title":"Example:","text":"<pre><code>class DynamicBlock(Block):\n    dynamic_inputs: list[Input[int]]\n    dynamic_outputs: dict[str, Output[int]]\n\n    @step()\n    async def process(self):\n        for input_value in self.dynamic_inputs:\n            output_value = input_value * 2\n            self.dynamic_outputs[str(input_value)].send(output_value)\n</code></pre>"},{"location":"concepts/blocks/custom-blocks-building/#8-examples","title":"8. Examples","text":""},{"location":"concepts/blocks/custom-blocks-building/#example-map-block","title":"Example: Map Block","text":"<p>The <code>Map</code> block applies a tool to each item in a list and collects the results.</p> <pre><code>from smartspace.core import Block, Tool, Output, step, callback\n\nclass Map(Block):\n    class Operation(Tool):\n        def run(self, item: int) -&gt; int:\n            return item * 2\n\n    results: Output[list[int]]\n\n    @step()\n    async def map(self, items: list[int]):\n        self.results.send([self.run.call(item) for item in items])\n</code></pre>"},{"location":"concepts/blocks/custom-blocks-building/#example-collect-block","title":"Example: Collect Block","text":"<p>The <code>Collect</code> block collects data from a channel and outputs it once the channel closes.</p> <pre><code>from smartspace.core import Block, InputChannel, Output, step\n\nclass Collect(Block):\n    items: Output[list[int]]\n\n    @step()\n    async def collect(self, item: InputChannel[int]):\n        items = []\n        while not item.closed:\n            data = await item.receive()\n            items.append(data)\n\n        self.items.send(items)\n</code></pre>"},{"location":"concepts/blocks/custom-blocks-building/#conclusion","title":"Conclusion","text":"<p>Blocks in SmartSpace are highly customizable and can be tailored to perform specific tasks within workflows. By following the examples above, you can create new blocks to expand the functionality of the SmartSpace platform. Remember to define inputs, outputs, and states clearly, and use the appropriate decorators (<code>@step</code>, <code>@callback</code>, <code>@metadata</code>) to create powerful and reusable components.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Coming soon...</p>"}]}